{
"id": "erp-java-001",
"conversations": [
{
"role": "user",
"content": "我需要为ERP系统添加一个新的库存管理功能，应该如何定义模块和包结构？"
},
{
"role": "assistant",
"content": "对于库存管理功能，你应该使用WM（Warehouse Management）作为模块标识。\n\n包结构应遵循以下规范：\n1. 基本包路径：`com.company.erp.wm`\n2. 内部结构：\n   - `com.company.erp.wm.entity` - 存放实体类\n   - `com.company.erp.wm.formula` - 存放业务逻辑处理类\n   - `com.company.erp.wm.registry` - 存放注册器类\n   - `com.company.erp.wm.common` - 存放公共组件\n\n这符合我们的分层架构设计，WM模块属于业务层(erp-supplychain-all)，需要依赖基础层(erp-basis-all)的功能。"
},
{
"role": "user",
"content": "库存管理相关的数据库表应该如何命名？"
},
{
"role": "assistant",
"content": "库存管理(WM)模块的数据库表命名应遵循以下规范：\n\n1. 模块表前缀：`EWM_`\n   - 例如：`EWM_StockHead` (库存主表)\n   - 例如：`EWM_StockMovement` (库存移动表)\n\n2. 模块缓存表前缀：`EGWM_`\n   - 例如：`EGWM_WarehouseConfig` (仓库配置缓存表)\n\n3. 表名示例：\n   - `EWM_InventoryHead` - 库存单据头表\n   - `EWM_InventoryItem` - 库存单据明细表\n   - `EWM_StockBalance` - 库存余额表\n   - `EGWM_LocationMaster` - 库位主数据缓存表\n\n记住，表名必须符合模块前缀规则，并使用英文名称准确描述表的业务用途。"
},
{
"role": "user",
"content": "我想开发一个库存移动的业务功能，Formula类应该如何设计？"
},
{
"role": "assistant",
"content": "库存移动功能的Formula类设计应遵循以下规范：\n\n```java\npackage com.company.erp.wm.formula;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.company.erp.function.EntityContextAction;\nimport com.company.erp.wm.entity.StockMovement;\n\npublic class StockMovementFormula extends EntityContextAction {\n    private static final Logger logger = LoggerFactory.getLogger(StockMovementFormula.class);\n\n    public StockMovementFormula(IMidContext context) throws Throwable {\n        super(context);\n    }\n    \n    /**\n     * 保存库存移动单据\n     * @param stockMovement 库存移动实体\n     * @return 保存后的实体ID\n     * @throws Throwable 处理异常\n     */\n    public Long save(StockMovement stockMovement) throws Throwable {\n        logger.info(\"开始保存库存移动单据\");\n        \n        // 1. 验证必填字段\n        validateRequiredFields(stockMovement);\n        \n        // 2. 生成单据编号\n        if (stockMovement.getDocumentNumber() == null) {\n            String docNumber = DocumentFunction.generateDocumentNumber(\n                getMidContext(),\n                \"WM\",     // 模块代码\n                \"SM\"      // 单据类型 StockMovement\n            );\n            stockMovement.setDocumentNumber(docNumber);\n        }\n        \n        // 3. 保存主表数据\n        Long objectID = getMidContext().saveObject(stockMovement);\n        \n        // 4. 保存明细数据（如果有）\n        saveDetails(stockMovement);\n        \n        // 5. 更新单据状态\n        StatusFormula statusFormula = new StatusFormula(getMidContext());\n        statusFormula.changeStatus(\n            true,\n            \"WM_StockMovement\",\n            \"SaveStockMovement\",\n            objectID,\n            getStatusProfileID(),\n            null\n        );\n        \n        logger.info(\"库存移动单据保存完成，ID: {}\", objectID);\n        return objectID;\n    }\n    \n    /**\n     * 验证必填字段\n     * @param stockMovement 库存移动实体\n     * @throws Throwable 验证失败抛出异常\n     */\n    private void validateRequiredFields(StockMovement stockMovement) throws Throwable {\n        if (stockMovement.getWarehouseID() == null) {\n            throw new Throwable(\"仓库不能为空\");\n        }\n        \n        if (stockMovement.getMoveDate() == null) {\n            throw new Throwable(\"移动日期不能为空\");\n        }\n        \n        // 其他业务验证...\n    }\n    \n    /**\n     * 保存明细数据\n     * @param stockMovement 库存移动实体\n     * @throws Throwable 处理异常\n     */\n    private void saveDetails(StockMovement stockMovement) throws Throwable {\n        // 明细数据保存逻辑...\n    }\n    \n    // 其他业务方法...\n}\n```\n\n同时，需要在WM模块的注册器中注册这个Formula类：\n\n```java\npackage com.company.erp.wm.registry;\n\nimport com.company.erp.function.IExtendContextActionRegistry;\nimport com.company.erp.wm.formula.StockMovementFormula;\n\npublic class WMContextActionRegistry implements IExtendContextActionRegistry {\n    @Override\n    public Class<?>[] getContextActions() {\n        Class<?>[] contextActions = new Class<?>[]{\n            StockMovementFormula.class,\n            // ... 其他WM模块Formula类\n        };\n        return contextActions;\n    }\n}\n```\n\n并确保在META-INF/services目录下的接口文件中添加注册器：\n```\ncom.company.erp.wm.registry.WMContextActionRegistry\n```"
}
]
}
{
"id": "erp-java-002",
"conversations": [
{
"role": "user",
"content": "如何设计ERP系统中的实体类？以采购订单为例。"
},
{
"role": "assistant",
"content": "在ERP系统中设计采购订单(PurchaseOrder)实体类应遵循以下规范：\n\n```java\npackage com.company.erp.mm.entity;\n\nimport java.math.BigDecimal;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * 采购订单实体类\n */\npublic class PurchaseOrder {\n    // 系统字段常量定义\n    public static final String FIELD_OID = \"OID\";\n    public static final String FIELD_SOID = \"SOID\";\n    public static final String FIELD_POID = \"POID\";\n    public static final String FIELD_STATUS = \"Status\";\n    \n    // 业务字段常量定义\n    public static final String FIELD_DOC_NUMBER = \"DocumentNumber\";\n    public static final String FIELD_VENDOR_ID = \"VendorID\";\n    public static final String FIELD_ORDER_DATE = \"OrderDate\";\n    public static final String FIELD_CURRENCY = \"Currency\";\n    public static final String FIELD_TOTAL_AMOUNT = \"TotalAmount\";\n    \n    // 系统字段\n    private Long oid;\n    private Long soid;\n    private Long poid;\n    private Integer status;\n    private Long creator;\n    private Date createTime;\n    private Long modifier;\n    private Date modifyTime;\n    \n    // 业务字段\n    private String documentNumber;\n    private Long vendorID;\n    private String vendorName;\n    private Date orderDate;\n    private String currency;\n    private BigDecimal totalAmount;\n    \n    // 明细列表（不持久化，仅用于传输）\n    private List<PurchaseOrderItem> items;\n    \n    // 构造函数\n    public PurchaseOrder() {\n    }\n    \n    // getter/setter方法（支持链式调用）\n    public Long getOid() {\n        return oid;\n    }\n    \n    public PurchaseOrder setOid(Long oid) {\n        this.oid = oid;\n        return this;\n    }\n    \n    public String getDocumentNumber() {\n        return documentNumber;\n    }\n    \n    public PurchaseOrder setDocumentNumber(String documentNumber) {\n        this.documentNumber = documentNumber;\n        return this;\n    }\n    \n    public Long getVendorID() {\n        return vendorID;\n    }\n    \n    public PurchaseOrder setVendorID(Long vendorID) {\n        this.vendorID = vendorID;\n        return this;\n    }\n    \n    // 其他getter/setter方法...\n}\n```\n\n该实体类设计遵循以下规范：\n1. 放在对应业务模块的entity包下（com.company.erp.mm.entity）\n2. 使用英文名称作为类名（PurchaseOrder）\n3. 字段常量定义为public static final\n4. getter/setter方法支持链式调用\n5. 包含系统字段和业务字段\n6. 包含适当的JavaDoc注释"
},
{
"role": "user",
"content": "采购订单明细实体类应该怎么设计？"
},
{
"role": "assistant",
"content": "采购订单明细(PurchaseOrderItem)实体类设计应遵循以下规范：\n\n```java\npackage com.company.erp.mm.entity;\n\nimport java.math.BigDecimal;\nimport java.util.Date;\n\n/**\n * 采购订单明细实体类\n */\npublic class PurchaseOrderItem {\n    // 系统字段常量定义\n    public static final String FIELD_OID = \"OID\";\n    public static final String FIELD_SOID = \"SOID\";\n    public static final String FIELD_POID = \"POID\";\n    \n    // 业务字段常量定义\n    public static final String FIELD_LINE_NUMBER = \"LineNumber\";\n    public static final String FIELD_MATERIAL_ID = \"MaterialID\";\n    public static final String FIELD_QUANTITY = \"Quantity\";\n    public static final String FIELD_UNIT_PRICE = \"UnitPrice\";\n    public static final String FIELD_AMOUNT = \"Amount\";\n    \n    // 系统字段\n    private Long oid;\n    private Long soid;  // 关联主表ID\n    private Long poid;\n    private Long creator;\n    private Date createTime;\n    private Long modifier;\n    private Date modifyTime;\n    \n    // 业务字段\n    private Integer lineNumber;  // 行号\n    private Long materialID;     // 物料ID\n    private String materialCode; // 物料编码\n    private String materialName; // 物料名称\n    private String unit;         // 单位\n    private BigDecimal quantity;  // 数量（精度：16,3）\n    private BigDecimal unitPrice; // 单价（精度：16,2）\n    private BigDecimal amount;    // 金额（精度：16,2）\n    private Date deliveryDate;   // 交货日期\n    private String remark;       // 备注\n    \n    // 构造函数\n    public PurchaseOrderItem() {\n    }\n    \n    // getter/setter方法（支持链式调用）\n    public Long getOid() {\n        return oid;\n    }\n    \n    public PurchaseOrderItem setOid(Long oid) {\n        this.oid = oid;\n        return this;\n    }\n    \n    public Long getSoid() {\n        return soid;\n    }\n    \n    public PurchaseOrderItem setSoid(Long soid) {\n        this.soid = soid;\n        return this;\n    }\n    \n    public Integer getLineNumber() {\n        return lineNumber;\n    }\n    \n    public PurchaseOrderItem setLineNumber(Integer lineNumber) {\n        this.lineNumber = lineNumber;\n        return this;\n    }\n    \n    public Long getMaterialID() {\n        return materialID;\n    }\n    \n    public PurchaseOrderItem setMaterialID(Long materialID) {\n        this.materialID = materialID;\n        return this;\n    }\n    \n    // 其他getter/setter方法...\n}\n```\n\n明细实体类设计要点：\n1. 放在与主表实体相同的包下（com.company.erp.mm.entity）\n2. 使用英文名称作为类名（PurchaseOrderItem）\n3. 包含关联主表ID的字段（soid）\n4. 包含行号字段（lineNumber）用于排序\n5. 包含数量、价格等关键业务字段，注意数值精度\n6. getter/setter方法支持链式调用\n7. 遵循统一的字段常量定义方式\n\n这种设计符合ERP系统的实体类标准，确保了实体类的一致性和可维护性。"
},
{
"role": "user",
"content": "如何在XML中定义采购订单的DataObject？"
},
{
"role": "assistant",
"content": "采购订单的DataObject XML定义应遵循以下规范：\n\n```xml\n<DataObject Key=\"MM_PurchaseOrder\" Caption=\"采购订单\" PrimaryTableKey=\"EMM_PurchaseOrderHead\" PrimaryType=\"Entity\" Version=\"1\">\n    <TableCollection>\n        <!-- 采购订单主表定义 -->\n        <Table Key=\"EMM_PurchaseOrderHead\" Caption=\"采购订单头表\" IndexPrefix=\"EMM_PurchaseOrderHead\">\n            <!-- 系统字段 -->\n            <Column Key=\"OID\" Caption=\"对象标识\" DataType=\"Long\" />\n            <Column Key=\"SOID\" Caption=\"主对象标识\" DataType=\"Long\" />\n            <Column Key=\"POID\" Caption=\"父对象标识\" DataType=\"Long\" />\n            <Column Key=\"VERID\" Caption=\"对象版本\" DataType=\"Integer\" />\n            <Column Key=\"Status\" Caption=\"状态\" DataType=\"Integer\" />\n            <Column Key=\"Creator\" Caption=\"制单人\" DataType=\"Long\" />\n            <Column Key=\"CreateTime\" Caption=\"制单时间\" DataType=\"DateTime\" />\n            <Column Key=\"Modifier\" Caption=\"修改人\" DataType=\"Long\" />\n            <Column Key=\"ModifyTime\" Caption=\"修改时间\" DataType=\"DateTime\" />\n            \n            <!-- 业务字段 -->\n            <Column Key=\"DocumentNumber\" Caption=\"采购订单号\" DataType=\"Varchar\" Length=\"20\" />\n            <Column Key=\"OrderDate\" Caption=\"订单日期\" DataType=\"DateTime\" />\n            <Column Key=\"VendorID\" Caption=\"供应商ID\" DataType=\"Long\" />\n            <Column Key=\"VendorCode\" Caption=\"供应商编码\" DataType=\"Varchar\" Length=\"20\" />\n            <Column Key=\"VendorName\" Caption=\"供应商名称\" DataType=\"Varchar\" Length=\"100\" />\n            <Column Key=\"PurchaserID\" Caption=\"采购员ID\" DataType=\"Long\" />\n            <Column Key=\"PurchaserName\" Caption=\"采购员\" DataType=\"Varchar\" Length=\"50\" />\n            <Column Key=\"DepartmentID\" Caption=\"部门ID\" DataType=\"Long\" />\n            <Column Key=\"DepartmentName\" Caption=\"部门\" DataType=\"Varchar\" Length=\"50\" />\n            <Column Key=\"Currency\" Caption=\"币种\" DataType=\"Varchar\" Length=\"10\" />\n            <Column Key=\"ExchangeRate\" Caption=\"汇率\" DataType=\"Numeric\" Precision=\"16\" Scale=\"6\" />\n            <Column Key=\"TotalAmount\" Caption=\"总金额\" DataType=\"Numeric\" Precision=\"16\" Scale=\"2\" />\n            <Column Key=\"DeliveryDate\" Caption=\"交货日期\" DataType=\"DateTime\" />\n            <Column Key=\"PaymentTerms\" Caption=\"付款条件\" DataType=\"Varchar\" Length=\"100\" />\n            <Column Key=\"Remark\" Caption=\"备注\" DataType=\"Varchar\" Length=\"500\" />\n        </Table>\n        \n        <!-- 采购订单明细表定义 -->\n        <Table Key=\"EMM_PurchaseOrderItem\" TableMode=\"Detail\" Caption=\"采购订单明细\" IndexPrefix=\"EMM_PurchaseOrderItem\">\n            <!-- 系统字段 -->\n            <Column Key=\"OID\" Caption=\"对象标识\" DataType=\"Long\" />\n            <Column Key=\"SOID\" Caption=\"主对象标识\" DataType=\"Long\" />\n            <Column Key=\"POID\" Caption=\"父对象标识\" DataType=\"Long\" />\n            <Column Key=\"VERID\" Caption=\"对象版本\" DataType=\"Integer\" />\n            <Column Key=\"Creator\" Caption=\"制单人\" DataType=\"Long\" />\n            <Column Key=\"CreateTime\" Caption=\"制单时间\" DataType=\"DateTime\" />\n            <Column Key=\"Modifier\" Caption=\"修改人\" DataType=\"Long\" />\n            <Column Key=\"ModifyTime\" Caption=\"修改时间\" DataType=\"DateTime\" />\n            \n            <!-- 业务字段 -->\n            <Column Key=\"LineNumber\" Caption=\"行号\" DataType=\"Integer\" />\n            <Column Key=\"MaterialID\" Caption=\"物料ID\" DataType=\"Long\" />\n            <Column Key=\"MaterialCode\" Caption=\"物料编码\" DataType=\"Varchar\" Length=\"50\" />\n            <Column Key=\"MaterialName\" Caption=\"物料名称\" DataType=\"Varchar\" Length=\"100\" />\n            <Column Key=\"Specification\" Caption=\"规格型号\" DataType=\"Varchar\" Length=\"100\" />\n            <Column Key=\"Unit\" Caption=\"单位\" DataType=\"Varchar\" Length=\"20\" />\n            <Column Key=\"Quantity\" Caption=\"数量\" DataType=\"Numeric\" Precision=\"16\" Scale=\"3\" />\n            <Column Key=\"UnitPrice\" Caption=\"单价\" DataType=\"Numeric\" Precision=\"16\" Scale=\"2\" />\n            <Column Key=\"Amount\" Caption=\"金额\" DataType=\"Numeric\" Precision=\"16\" Scale=\"2\" />\n            <Column Key=\"TaxRate\" Caption=\"税率\" DataType=\"Numeric\" Precision=\"16\" Scale=\"2\" />\n            <Column Key=\"TaxAmount\" Caption=\"税额\" DataType=\"Numeric\" Precision=\"16\" Scale=\"2\" />\n            <Column Key=\"DeliveryDate\" Caption=\"交货日期\" DataType=\"DateTime\" />\n            <Column Key=\"WarehouseID\" Caption=\"仓库ID\" DataType=\"Long\" />\n            <Column Key=\"WarehouseName\" Caption=\"仓库\" DataType=\"Varchar\" Length=\"50\" />\n            <Column Key=\"Remark\" Caption=\"备注\" DataType=\"Varchar\" Length=\"200\" />\n        </Table>\n    </TableCollection>\n</DataObject>\n```\n\nDataObject定义要点：\n\n1. DataObject命名规则：\n   - Key属性：`MM_PurchaseOrder`（模块_实体）\n   - PrimaryTableKey：`EMM_PurchaseOrderHead`（表前缀E + 模块标识MM + 实体名Head）\n\n2. 表命名规则：\n   - 主表Key：`EMM_PurchaseOrderHead`\n   - 明细表Key：`EMM_PurchaseOrderItem`\n   - 明细表需设置TableMode=\"Detail\"\n\n3. 系统字段：\n   - 包含必要的系统字段（OID, SOID, POID, VERID等）\n   - 包含创建/修改相关的审计字段\n\n4. 数据类型规范：\n   - 字符串：DataType=\"Varchar\" Length=\"长度值\"\n   - 整数：DataType=\"Integer\"\n   - 长整数：DataType=\"Long\"\n   - 数量小数：DataType=\"Numeric\" Precision=\"16\" Scale=\"3\"\n   - 金额小数：DataType=\"Numeric\" Precision=\"16\" Scale=\"2\"\n   - 日期时间：DataType=\"DateTime\"\n\n5. 索引前缀：与表Key保持一致\n\n该DataObject定义符合ERP系统的标准规范，确保了数据结构的一致性和可维护性。"
}
]
}
{
"id": "erp-java-003",
"conversations": [
{
"role": "user",
"content": "请解释一下ERP系统中Formula类的作用和开发规范。"
},
{
"role": "assistant",
"content": "在ERP系统中，Formula类是业务逻辑处理的核心组件，主要负责实现特定业务领域的功能逻辑。以下是Formula类的作用和开发规范：\n\n## Formula类的作用\n\n1. **业务逻辑封装**：将特定业务领域的逻辑封装在专门的Formula类中\n2. **状态管理**：负责管理业务对象的状态转换\n3. **数据验证**：执行业务规则验证和数据完整性检查\n4. **事务处理**：在业务上下文中执行事务性操作\n5. **业务流程控制**：控制业务处理流程，如审核、取消等\n\n## Formula类开发规范\n\n### 1. 基本结构\n\n```java\npublic class 业务Formula extends EntityContextAction {\n    private static final Logger logger = LoggerFactory.getLogger(业务Formula.class);\n\n    public 业务Formula(IMidContext context) throws Throwable {\n        super(context);\n    }\n\n    // 业务方法实现\n}\n```\n\n### 2. 命名规范\n- 命名规则：`实体名 + Formula`\n- 例如：`PurchaseOrderFormula`, `SalesOrderFormula`\n\n### 3. 包路径规范\n- 必须放在对应业务模块的formula包下\n- 例如：`com.company.erp.mm.formula.PurchaseOrderFormula`\n\n### 4. 继承关系\n- 必须继承`EntityContextAction`基类\n- 通过基类获取上下文和核心功能\n\n### 5. 构造函数\n- 必须包含接收`IMidContext`参数的构造函数\n- 必须处理异常（throws Throwable）\n\n### 6. 业务方法规范\n- 方法必须抛出Throwable异常\n- 必须包含日志记录\n- 必须进行参数验证\n- 必须进行权限检查\n- 必须维护单据状态\n\n### 7. 状态管理示例\n```java\n// 状态变更示例\nStatusFormula statusFormula = new StatusFormula(getMidContext());\nstatusFormula.changeStatus(\n    true,                   // 是否更新文档\n    \"业务对象类型\",          // 如：MM_PurchaseOrder\n    \"业务事务代码\",          // 如：SavePurchaseOrder\n    objectID,              // 对象ID\n    statusProfileID,       // 状态配置ID\n    statusInfo             // 状态信息\n);\n```\n\n### 8. 单据编号生成规范\n```java\n// 生成单据编号\nString docNumber = DocumentFunction.generateDocumentNumber(\n    getMidContext(),\n    \"MM\",     // 模块代码\n    \"PO\"      // 单据类型\n);\n```\n\n### 9. 模块注册\n- 每个Formula类必须在对应模块的ContextActionRegistry中注册\n- 通过SPI机制向系统注册Formula类\n\n遵循这些规范可以确保业务逻辑处理的一致性、可维护性和可扩展性，使ERP系统保持良好的架构特性。"
},
{
"role": "user",
"content": "能给我一个完整的采购订单Formula类实现示例吗？"
},
{
"role": "assistant",
"content": "以下是一个完整的采购订单(PurchaseOrder)Formula类实现示例：\n\n```java\npackage com.company.erp.mm.formula;\n\nimport java.math.BigDecimal;\nimport java.util.Date;\nimport java.util.List;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.company.erp.function.EntityContextAction;\nimport com.company.erp.function.DocumentFunction;\nimport com.company.erp.mm.entity.PurchaseOrder;\nimport com.company.erp.mm.entity.PurchaseOrderItem;\n\n/**\n * 采购订单业务逻辑处理类\n */\npublic class PurchaseOrderFormula extends EntityContextAction {\n    private static final Logger logger = LoggerFactory.getLogger(PurchaseOrderFormula.class);\n    \n    // 状态常量定义\n    public static final int STATUS_DRAFT = 10;        // 草稿\n    public static final int STATUS_SUBMITTED = 20;    // 已提交\n    public static final int STATUS_APPROVED = 30;     // 已审批\n    public static final int STATUS_CLOSED = 40;       // 已关闭\n    public static final int STATUS_CANCELED = 90;     // 已取消\n    \n    /**\n     * 构造函数\n     * @param context 上下文\n     * @throws Throwable 异常\n     */\n    public PurchaseOrderFormula(IMidContext context) throws Throwable {\n        super(context);\n    }\n    \n    /**\n     * 保存采购订单\n     * @param purchaseOrder 采购订单实体\n     * @return 采购订单ID\n     * @throws Throwable 处理异常\n     */\n    public Long save(PurchaseOrder purchaseOrder) throws Throwable {\n        logger.info(\"开始保存采购订单\");\n        \n        // 1. 验证必填字段\n        validateRequiredFields(purchaseOrder);\n        \n        // 2. 生成单据编号（如果没有）\n        if (purchaseOrder.getDocumentNumber() == null || purchaseOrder.getDocumentNumber().isEmpty()) {\n            String docNumber = DocumentFunction.generateDocumentNumber(\n                getMidContext(),\n                \"MM\",     // 模块代码\n                \"PO\"      // 单据类型（采购订单）\n            );\n            purchaseOrder.setDocumentNumber(docNumber);\n        }\n        \n        // 3. 设置创建/修改信息\n        Date now = new Date();\n        Long currentUserID = getCurrentUserID();\n        \n        if (purchaseOrder.getOid() == null) {\n            // 新建单据\n            purchaseOrder.setCreator(currentUserID)\n                         .setCreateTime(now)\n                         .setStatus(STATUS_DRAFT);\n        }\n        \n        purchaseOrder.setModifier(currentUserID)\n                     .setModifyTime(now);\n        \n        // 4. 保存主表数据\n        Long objectID = getMidContext().saveObject(purchaseOrder);\n        purchaseOrder.setOid(objectID);\n        \n        // 5. 处理明细数据\n        processOrderItems(purchaseOrder);\n        \n        // 6. 更新状态\n        updateOrderStatus(purchaseOrder, STATUS_DRAFT);\n        \n        logger.info(\"采购订单保存完成，ID: {}\", objectID);\n        return objectID;\n    }\n    \n    /**\n     * 提交采购订单\n     * @param orderID 采购订单ID\n     * @return 处理结果\n     * @throws Throwable 处理异常\n     */\n    public boolean submit(Long orderID) throws Throwable {\n        logger.info(\"开始提交采购订单，ID: {}\", orderID);\n        \n        // 1. 获取采购订单\n        PurchaseOrder order = getOrder(orderID);\n        \n        // 2. 验证当前状态\n        if (order.getStatus() != STATUS_DRAFT) {\n            throw new Throwable(\"只有草稿状态的采购订单可以提交\");\n        }\n        \n        // 3. 执行业务验证\n        validateOrderForSubmit(order);\n        \n        // 4. 更新状态\n        updateOrderStatus(order, STATUS_SUBMITTED);\n        \n        logger.info(\"采购订单提交完成，ID: {}\", orderID);\n        return true;\n    }\n    \n    /**\n     * 审批采购订单\n     * @param orderID 采购订单ID\n     * @return 处理结果\n     * @throws Throwable 处理异常\n     */\n    public boolean approve(Long orderID) throws Throwable {\n        logger.info(\"开始审批采购订单，ID: {}\", orderID);\n        \n        // 1. 获取采购订单\n        PurchaseOrder order = getOrder(orderID);\n        \n        // 2. 验证当前状态\n        if (order.getStatus() != STATUS_SUBMITTED) {\n            throw new Throwable(\"只有已提交状态的采购订单可以审批\");\n        }\n        \n        // 3. 执行业务验证\n        validateOrderForApprove(order);\n        \n        // 4. 更新状态\n        updateOrderStatus(order, STATUS_APPROVED);\n        \n        // 5. 执行审批后业务操作\n        processAfterApprove(order);\n        \n        logger.info(\"采购订单审批完成，ID: {}\", orderID);\n        return true;\n    }\n    \n    /**\n     * 取消采购订单\n     * @param orderID 采购订单ID\n     * @param cancelReason 取消原因\n     * @return 处理结果\n     * @throws Throwable 处理异常\n     */\n    public boolean cancel(Long orderID, String cancelReason) throws Throwable {\n        logger.info(\"开始取消采购订单，ID: {}\", orderID);\n        \n        // 1. 获取采购订单\n        PurchaseOrder order = getOrder(orderID);\n        \n        // 2. 验证当前状态\n        if (order.getStatus() == STATUS_CLOSED || order.getStatus() == STATUS_CANCELED) {\n            throw new Throwable(\"已关闭或已取消的采购订单不能再次取消\");\n        }\n        \n        // 3. 验证取消条件\n        validateOrderForCancel(order);\n        \n        // 4. 更新状态\n        updateOrderStatus(order, STATUS_CANCELED);\n        \n        // 5. 记录取消原因\n        saveOrderRemark(orderID, \"取消原因: \" + cancelReason);\n        \n        logger.info(\"采购订单取消完成，ID: {}\", orderID);\n        return true;\n    }\n    \n    /**\n     * 关闭采购订单\n     * @param orderID 采购订单ID\n     * @return 处理结果\n     * @throws Throwable 处理异常\n     */\n    public boolean close(Long orderID) throws Throwable {\n        logger.info(\"开始关闭采购订单，ID: {}\", orderID);\n        \n        // 1. 获取采购订单\n        PurchaseOrder order = getOrder(orderID);\n        \n        // 2. 验证当前状态\n        if (order.getStatus() != STATUS_APPROVED) {\n            throw new Throwable(\"只有已审批的采购订单可以关闭\");\n        }\n        \n        // 3. 验证关闭条件\n        validateOrderForClose(order);\n        \n        // 4. 更新状态\n        updateOrderStatus(order, STATUS_CLOSED);\n        \n        logger.info(\"采购订单关闭完成，ID: {}\", orderID);\n        return true;\n    }\n    \n    /**\n     * 获取采购订单\n     * @param orderID 采购订单ID\n     * @return 采购订单实体\n     * @throws Throwable 处理异常\n     */\n    private PurchaseOrder getOrder(Long orderID) throws Throwable {\n        if (orderID == null) {\n            throw new Throwable(\"采购订单ID不能为空\");\n        }\n        \n        PurchaseOrder order = (PurchaseOrder) getMidContext().getObject(PurchaseOrder.class, orderID);\n        if (order == null) {\n            throw new Throwable(\"采购订单不存在，ID: \" + orderID);\n        }\n        \n        return order;\n    }\n    \n    /**\n     * 验证必填字段\n     * @param purchaseOrder 采购订单实体\n     * @throws Throwable 验证失败抛出异常\n     */\n    private void validateRequiredFields(PurchaseOrder purchaseOrder) throws Throwable {\n        if (purchaseOrder == null) {\n            throw new Throwable(\"采购订单不能为空\");\n        }\n        \n        if (purchaseOrder.getVendorID() == null) {\n            throw new Throwable(\"供应商不能为空\");\n        }\n        \n        if (purchaseOrder.getOrderDate() == null) {\n            throw new Throwable(\"订单日期不能为空\");\n        }\n        \n        if (purchaseOrder.getCurrency() == null || purchaseOrder.getCurrency().isEmpty()) {\n            throw new Throwable(\"币种不能为空\");\n        }\n        \n        // 验证明细数据\n        List<PurchaseOrderItem> items = purchaseOrder.getItems();\n        if (items == null || items.isEmpty()) {\n            throw new Throwable(\"采购订单明细不能为空\");\n        }\n        \n        // 验证明细行\n        for (int i = 0; i < items.size(); i++) {\n            PurchaseOrderItem item = items.get(i);\n            if (item.getMaterialID() == null) {\n                throw new Throwable(\"第\" + (i + 1) + \"行物料不能为空\");\n            }\n            \n            if (item.getQuantity() == null || item.getQuantity().compareTo(BigDecimal.ZERO) <= 0) {\n                throw new Throwable(\"第\" + (i + 1) + \"行数量必须大于0\");\n            }\n            \n            if (item.getUnitPrice() == null || item.getUnitPrice().compareTo(BigDecimal.ZERO) < 0) {\n                throw new Throwable(\"第\" + (i + 1) + \"行单价不能小于0\");\n            }\n        }\n    }\n    \n    /**\n     * 处理订单明细\n     * @param purchaseOrder 采购订单实体\n     * @throws Throwable 处理异常\n     */\n    private void processOrderItems(PurchaseOrder purchaseOrder) throws Throwable {\n        List<PurchaseOrderItem> items = purchaseOrder.getItems();\n        if (items == null || items.isEmpty()) {\n            return;\n        }\n        \n        // 删除旧明细数据\n        if (purchaseOrder.getOid() != null) {\n            getMidContext().deleteObjects(\n                PurchaseOrderItem.class,\n                \"SOID = ?\",\n                new Object[] { purchaseOrder.getOid() }\n            );\n        }\n        \n        // 保存新明细数据\n        BigDecimal totalAmount = BigDecimal.ZERO;\n        for (int i = 0; i < items.size(); i++) {\n            PurchaseOrderItem item = items.get(i);\n            \n            // 设置行号\n            item.setLineNumber(i + 1);\n            \n            // 设置关联主表ID\n            item.setSoid(purchaseOrder.getOid());\n            \n            // 计算行金额\n            if (item.getQuantity() != null && item.getUnitPrice() != null) {\n                BigDecimal amount = item.getQuantity().multiply(item.getUnitPrice());\n                item.setAmount(amount);\n                totalAmount = totalAmount.add(amount);\n            }\n            \n            // 保存明细行\n            getMidContext().saveObject(item);\n        }\n        \n        // 更新主表总金额\n        purchaseOrder.setTotalAmount(totalAmount);\n        getMidContext().saveObject(purchaseOrder);\n    }\n    \n    /**\n     * 更新订单状态\n     * @param order 采购订单实体\n     * @param status 目标状态\n     * @throws Throwable 处理异常\n     */\n    private void updateOrderStatus(PurchaseOrder order, int status) throws Throwable {\n        // 更新实体状态\n        order.setStatus(status);\n        getMidContext().saveObject(order);\n        \n        // 使用状态公式更新状态\n        StatusFormula statusFormula = new StatusFormula(getMidContext());\n        statusFormula.changeStatus(\n            true,\n            \"MM_PurchaseOrder\",\n            getStatusTransactionCode(status),\n            order.getOid(),\n            getStatusProfileID(),\n            null\n        );\n    }\n    \n    /**\n     * 获取状态事务代码\n     * @param status 状态值\n     * @return 状态事务代码\n     */\n    private String getStatusTransactionCode(int status) {\n        switch (status) {\n            case STATUS_DRAFT:\n                return \"SavePurchaseOrder\";\n            case STATUS_SUBMITTED:\n                return \"SubmitPurchaseOrder\";\n            case STATUS_APPROVED:\n                return \"ApprovePurchaseOrder\";\n            case STATUS_CLOSED:\n                return \"ClosePurchaseOrder\";\n            case STATUS_CANCELED:\n                return \"CancelPurchaseOrder\";\n            default:\n                return \"UnknownTransaction\";\n        }\n    }\n    \n    /**\n     * 获取状态配置ID\n     * @return 状态配置ID\n     */\n    private Long getStatusProfileID() {\n        // 实际应用中，可能从配置或上下文中获取\n        return 1000L;\n    }\n    \n    /**\n     * 获取当前用户ID\n     * @return 用户ID\n     */\n    private Long getCurrentUserID() {\n        // 实际应用中，从上下文中获取当前用户ID\n        return getMidContext().getCurrentUserID();\n    }\n    \n    /**\n     * 保存订单备注\n     * @param orderID 订单ID\n     * @param remark 备注内容\n     * @throws Throwable 处理异常\n     */\n    private void saveOrderRemark(Long orderID, String remark) throws Throwable {\n        // 实际应用中，可能保存到备注表或更新订单备注字段\n        PurchaseOrder order = getOrder(orderID);\n        order.setRemark(remark);\n        getMidContext().saveObject(order);\n    }\n    \n    /**\n     * 验证订单提交条件\n     * @param order 采购订单实体\n     * @throws Throwable 验证失败抛出异常\n     */\n    private void validateOrderForSubmit(PurchaseOrder order) throws Throwable {\n        // 业务验证逻辑\n        // 例如：验证金额、验证供应商状态等\n    }\n    \n    /**\n     * 验证订单审批条件\n     * @param order 采购订单实体\n     * @throws Throwable 验证失败抛出异常\n     */\n    private void validateOrderForApprove(PurchaseOrder order) throws Throwable {\n        // 业务验证逻辑\n        // 例如：验证审批权限、验证预算等\n    }\n    \n    /**\n     * 验证订单取消条件\n     * @param order 采购订单实体\n     * @throws Throwable 验证失败抛出异常\n     */\n    private void validateOrderForCancel(PurchaseOrder order) throws Throwable {\n        // 业务验证逻辑\n        // 例如：验证是否已有关联单据等\n    }\n    \n    /**\n     * 验证订单关闭条件\n     * @param order 采购订单实体\n     * @throws Throwable 验证失败抛出异常\n     */\n    private void validateOrderForClose(PurchaseOrder order) throws Throwable {\n        // 业务验证逻辑\n        // 例如：验证是否全部收货等\n    }\n    \n    /**\n     * 处理审批后业务操作\n     * @param order 采购订单实体\n     * @throws Throwable 处理异常\n     */\n    private void processAfterApprove(PurchaseOrder order) throws Throwable {\n        // 审批后业务处理\n        // 例如：生成库存预留、通知供应商等\n    }\n}\n```\n\n这个完整的PurchaseOrderFormula类实现了采购订单的全生命周期管理，包括：\n\n1. **基本结构**：继承EntityContextAction，包含必要的构造函数和日志定义\n2. **状态管理**：定义了采购订单的各种状态常量和状态转换方法\n3. **业务方法**：实现了保存、提交、审批、取消、关闭等核心业务功能\n4. **数据验证**：包含了必填字段验证、业务规则验证等\n5. **明细处理**：处理采购订单明细数据，包括行号设置、金额计算等\n6. **辅助方法**：提供了各种辅助功能，如获取订单、获取用户ID等\n\n这个实现符合ERP系统的Formula类开发规范，确保了业务逻辑的一致性和可维护性。"
},
{
"role": "user",
"content": "如何在模块注册器中注册这个Formula类？"
},
{
"role": "assistant",
"content": "在ERP系统中，每个Formula类都需要通过模块注册器(ContextActionRegistry)进行注册，才能被系统识别和使用。以下是在模块注册器中注册PurchaseOrderFormula类的完整步骤：\n\n## 1. 创建模块注册器类\n\n首先，需要在模块的registry包中创建一个注册器类，实现`IExtendContextActionRegistry`接口：\n\n```java\npackage com.company.erp.mm.registry;\n\nimport com.company.erp.function.IExtendContextActionRegistry;\nimport com.company.erp.mm.formula.PurchaseOrderFormula;\nimport com.company.erp.mm.formula.MaterialFormula;\n// 导入其他Formula类...\n\n/**\n * 物料管理模块注册器\n */\npublic class MMContextActionRegistry implements IExtendContextActionRegistry {\n    \n    /**\n     * 获取上下文动作类列表\n     * @return Formula类数组\n     */\n    @Override\n    public Class<?>[] getContextActions() {\n        // 返回所有需要注册的Formula类\n        Class<?>[] contextActions = new Class<?>[] {\n            PurchaseOrderFormula.class,\n            MaterialFormula.class,\n            // 其他MM模块的Formula类...\n        };\n        return contextActions;\n    }\n}\n```\n\n## 2. 通过SPI机制注册\n\n接下来，需要通过Java的SPI(Service Provider Interface)机制将注册器注册到系统中。在`resources/META-INF/services`目录下创建一个文件，文件名为接口的全限定名：\n\n```\nresources/\n└── META-INF/\n    └── services/\n        └── com.company.erp.function.IExtendContextActionRegistry\n```\n\n文件内容为注册器类的全限定名，每行一个：\n\n```\ncom.company.erp.mm.registry.MMContextActionRegistry\ncom.company.erp.sd.registry.SDContextActionRegistry\n# 其他模块的注册器...\n```\n\n## 3. 注册流程说明\n\n1. **创建注册器类**：每个业务模块(如MM、SD等)都需要创建一个对应的ContextActionRegistry类\n2. **实现接口方法**：实现`getContextActions()`方法，返回该模块所有Formula类的Class对象数组\n3. **创建SPI配置文件**：在META-INF/services目录下创建接口全限定名文件\n4. **添加注册器类名**：在SPI配置文件中添加注册器类的全限定名\n\n## 4. 注册维护规范\n\n在开发过程中，需要遵循以下规范维护注册器：\n\n1. **新增Formula类**：当新增Formula类时，必须同步更新对应模块的注册器，将新类添加到`getContextActions()`方法返回的数组中\n\n   ```java\n   @Override\n   public Class<?>[] getContextActions() {\n       return new Class<?>[] {\n           PurchaseOrderFormula.class,\n           MaterialFormula.class,\n           NewFormula.class,  // 新增的Formula类\n       };\n   }\n   ```\n\n2. **删除Formula类**：当删除Formula类时，必须从注册器中移除对应的Class对象\n\n3. **模块划分**：每个业务模块必须有自己的注册器，不同模块的Formula类不应混合注册\n\n4. **命名规范**：注册器类必须遵循`模块标识ContextActionRegistry`的命名规则\n\n5. **包路径规范**：注册器类必须放在模块的registry包下\n\n## 5. 完整示例\n\n以下是一个完整的MM模块注册器示例，包含了多个Formula类的注册：\n\n```java\npackage com.company.erp.mm.registry;\n\nimport com.company.erp.function.IExtendContextActionRegistry;\nimport com.company.erp.mm.formula.PurchaseOrderFormula;\nimport com.company.erp.mm.formula.MaterialFormula;\nimport com.company.erp.mm.formula.InventoryFormula;\nimport com.company.erp.mm.formula.VendorFormula;\nimport com.company.erp.mm.formula.GoodsReceiptFormula;\n\n/**\n * 物料管理模块注册器\n */\npublic class MMContextActionRegistry implements IExtendContextActionRegistry {\n    \n    /**\n     * 获取上下文动作类列表\n     * @return Formula类数组\n     */\n    @Override\n    public Class<?>[] getContextActions() {\n        Class<?>[] contextActions = new Class<?>[] {\n            // 采购相关\n            PurchaseOrderFormula.class,\n            PurchaseRequestFormula.class,\n            PurchaseContractFormula.class,\n            \n            // 物料相关\n            MaterialFormula.class,\n            MaterialGroupFormula.class,\n            \n            // 库存相关\n            InventoryFormula.class,\n            GoodsReceiptFormula.class,\n            GoodsIssueFormula.class,\n            \n            // 供应商相关\n            VendorFormula.class,\n            VendorEvaluationFormula.class\n        };\n        return contextActions;\n    }\n}\n```\n\n通过这种方式，系统可以在启动时自动加载所有注册的Formula类，使它们能够被调用执行业务逻辑。这种基于SPI的注册机制使得模块之间保持松耦合，同时确保了业务逻辑的可扩展性和可维护性。"
},
{
"role": "user",
"content": "Formula类中如何处理单据的审批流程？"
},
{
"role": "assistant",
"content": "在ERP系统中，Formula类处理单据审批流程需要遵循一系列规范和最佳实践。以下是处理审批流程的关键步骤和实现方法：\n\n## 1. 审批流程基本步骤\n\n审批流程通常包含以下基本步骤：\n\n1. **状态验证**：检查单据当前状态是否允许审批\n2. **权限验证**：验证当前用户是否有审批权限\n3. **业务规则验证**：验证单据是否满足审批条件\n4. **状态更新**：更新单据状态为已审批\n5. **后续处理**：执行审批后的业务操作\n\n## 2. 审批方法实现示例\n\n```java\n/**\n * 审批单据\n * @param documentID 单据ID\n * @param approveRemark 审批备注\n * @return 处理结果\n * @throws Throwable 处理异常\n */\npublic boolean approve(Long documentID, String approveRemark) throws Throwable {\n    logger.info(\"开始审批单据，ID: {}\", documentID);\n    \n    // 1. 获取单据\n    Document document = getDocument(documentID);\n    \n    // 2. 验证当前状态\n    if (document.getStatus() != STATUS_SUBMITTED) {\n        throw new Throwable(\"只有已提交状态的单据可以审批\");\n    }\n    \n    // 3. 验证审批权限\n    validateApprovePermission(document);\n    \n    // 4. 执行业务验证\n    validateDocumentForApprove(document);\n    \n    // 5. 更新状态\n    updateDocumentStatus(document, STATUS_APPROVED);\n    \n    // 6. 记录审批信息\n    saveApproveInfo(documentID, approveRemark);\n    \n    // 7. 执行审批后业务操作\n    processAfterApprove(document);\n    \n    logger.info(\"单据审批完成，ID: {}\", documentID);\n    return true;\n}\n```\n\n## 3. 权限验证实现\n\n```java\n/**\n * 验证审批权限\n * @param document 单据实体\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateApprovePermission(Document document) throws Throwable {\n    // 获取当前用户ID\n    Long currentUserID = getCurrentUserID();\n    \n    // 获取当前用户角色\n    List<String> userRoles = getUserRoles(currentUserID);\n    \n    // 检查是否有审批权限\n    boolean hasPermission = false;\n    \n    // 检查是否为审批人\n    if (document.getApproverID() != null && document.getApproverID().equals(currentUserID)) {\n        hasPermission = true;\n    }\n    \n    // 检查是否有审批角色\n    if (!hasPermission && userRoles.contains(\"APPROVER\")) {\n        hasPermission = true;\n    }\n    \n    // 检查是否有管理员角色\n    if (!hasPermission && userRoles.contains(\"ADMIN\")) {\n        hasPermission = true;\n    }\n    \n    if (!hasPermission) {\n        throw new Throwable(\"当前用户没有审批权限\");\n    }\n}\n```\n\n## 4. 状态管理实现\n\n```java\n/**\n * 更新单据状态\n * @param document 单据实体\n * @param status 目标状态\n * @throws Throwable 处理异常\n */\nprivate void updateDocumentStatus(Document document, int status) throws Throwable {\n    // 更新实体状态\n    document.setStatus(status);\n    getMidContext().saveObject(document);\n    \n    // 使用状态公式更新状态\n    StatusFormula statusFormula = new StatusFormula(getMidContext());\n    statusFormula.changeStatus(\n        true,                   // 是否更新文档\n        document.getDocumentType(),  // 单据类型\n        getStatusTransactionCode(status),  // 事务代码\n        document.getOid(),           // 对象ID\n        getStatusProfileID(),        // 状态配置ID\n        null                         // 状态信息\n    );\n    \n    // 记录状态变更日志\n    logStatusChange(document, status);\n}\n```\n\n## 5. 审批后处理实现\n\n```java\n/**\n * 处理审批后业务操作\n * @param document 单据实体\n * @throws Throwable 处理异常\n */\nprivate void processAfterApprove(Document document) throws Throwable {\n    // 1. 生成后续单据\n    generateFollowingDocuments(document);\n    \n    // 2. 更新相关业务数据\n    updateRelatedBusinessData(document);\n    \n    // 3. 发送通知\n    sendApprovalNotification(document);\n    \n    // 4. 触发其他业务流程\n    triggerBusinessProcess(document);\n}\n```\n\n## 6. 审批流程与工作流集成\n\n在更复杂的系统中，审批流程可能需要与工作流引擎集成：\n\n```java\n/**\n * 启动工作流审批流程\n * @param document 单据实体\n * @throws Throwable 处理异常\n */\nprivate void startWorkflowProcess(Document document) throws Throwable {\n    // 获取工作流引擎服务\n    WorkflowService workflowService = getWorkflowService();\n    \n    // 创建工作流参数\n    Map<String, Object> parameters = new HashMap<>();\n    parameters.put(\"documentID\", document.getOid());\n    parameters.put(\"documentType\", document.getDocumentType());\n    parameters.put(\"creatorID\", document.getCreator());\n    parameters.put(\"amount\", document.getTotalAmount());\n    \n    // 启动工作流程\n    String processInstanceID = workflowService.startProcess(\n        \"approvalProcess\",  // 流程定义ID\n        document.getOid().toString(),  // 业务键\n        parameters  // 流程参数\n    );\n    \n    // 保存流程实例ID到单据\n    document.setProcessInstanceID(processInstanceID);\n    getMidContext().saveObject(document);\n    \n    logger.info(\"启动审批工作流，单据ID: {}, 流程实例ID: {}\", document.getOid(), processInstanceID);\n}\n```\n\n## 7. 多级审批实现\n\n对于需要多级审批的场景，可以实现如下方法：\n\n```java\n/**\n * 处理多级审批\n * @param documentID 单据ID\n * @param approveLevel 审批级别\n * @param approveRemark 审批备注\n * @return 处理结果\n * @throws Throwable 处理异常\n */\npublic boolean approveByLevel(Long documentID, int approveLevel, String approveRemark) throws Throwable {\n    logger.info(\"开始{}级审批，单据ID: {}\", approveLevel, documentID);\n    \n    // 1. 获取单据\n    Document document = getDocument(documentID);\n    \n    // 2. 验证当前审批级别\n    int currentApproveLevel = document.getApproveLevel();\n    if (approveLevel != currentApproveLevel + 1) {\n        throw new Throwable(\"当前审批级别不正确，期望级别: \" + (currentApproveLevel + 1) + \", 实际级别: \" + approveLevel);\n    }\n    \n    // 3. 验证审批权限\n    validateApproveLevelPermission(document, approveLevel);\n    \n    // 4. 更新审批级别\n    document.setApproveLevel(approveLevel);\n    \n    // 5. 检查是否为最终审批\n    int maxApproveLevel = getMaxApproveLevel(document);\n    if (approveLevel >= maxApproveLevel) {\n        // 最终审批，更新状态为已审批\n        updateDocumentStatus(document, STATUS_APPROVED);\n        processAfterApprove(document);\n    } else {\n        // 中间审批，更新状态为审批中\n        updateDocumentStatus(document, STATUS_APPROVING);\n        // 通知下一级审批人\n        notifyNextApprover(document, approveLevel + 1);\n    }\n    \n    // 6. 记录审批信息\n    saveApproveLevelInfo(documentID, approveLevel, approveRemark);\n    \n    logger.info(\"{}级审批完成，单据ID: {}\", approveLevel, documentID);\n    return true;\n}\n```\n\n## 8. 审批历史记录\n\n```java\n/**\n * 保存审批信息\n * @param documentID 单据ID\n * @param approveRemark 审批备注\n * @throws Throwable 处理异常\n */\nprivate void saveApproveInfo(Long documentID, String approveRemark) throws Throwable {\n    // 创建审批历史记录\n    ApprovalHistory history = new ApprovalHistory();\n    history.setDocumentID(documentID)\n           .setApproverID(getCurrentUserID())\n           .setApproveTime(new Date())\n           .setApproveRemark(approveRemark);\n    \n    // 保存审批历史\n    getMidContext().saveObject(history);\n}\n```\n\n通过以上方法和规范，Formula类可以有效地处理单据的审批流程，确保业务流程的一致性、可追溯性和安全性。这种实现方式符合ERP系统的业务逻辑处理规范，能够满足企业级应用的审批需求。"
},
{
"role": "user",
"content": "Formula类如何处理单据编号生成？"
},
{
"role": "assistant",
"content": "在ERP系统中，单据编号是业务单据的重要标识，Formula类需要按照规范处理单据编号的生成。以下是Formula类处理单据编号生成的详细说明：\n\n## 1. 单据编号生成基本原则\n\n单据编号生成需要遵循以下基本原则：\n\n1. **唯一性**：系统内单据编号必须唯一\n2. **可读性**：编号应具有一定的业务含义\n3. **规范性**：遵循统一的编号规则\n4. **可追溯性**：能够反映业务信息（如日期、模块等）\n5. **连续性**：同类型单据编号应保持连续\n\n## 2. 使用DocumentFunction生成单据编号\n\n在Formula类中，通常使用系统提供的`DocumentFunction`工具类生成单据编号：\n\n```java\n/**\n * 生成单据编号\n * @param document 单据实体\n * @throws Throwable 处理异常\n */\nprivate void generateDocumentNumber(Document document) throws Throwable {\n    // 检查是否已有编号\n    if (document.getDocumentNumber() == null || document.getDocumentNumber().isEmpty()) {\n        // 使用DocumentFunction生成编号\n        String docNumber = DocumentFunction.generateDocumentNumber(\n            getMidContext(),\n            \"MM\",     // 模块代码\n            \"PO\"      // 单据类型\n        );\n        document.setDocumentNumber(docNumber);\n        logger.info(\"生成单据编号: {}\", docNumber);\n    }\n}\n```\n\n## 3. 编号规则配置\n\n单据编号规则通常在系统配置中定义，包括以下要素：\n\n1. **前缀**：通常包含模块代码和单据类型\n2. **日期部分**：年月日等时间信息\n3. **序号部分**：连续的数字序列\n4. **分隔符**：用于分隔各部分的字符\n\n例如，采购订单编号可能为：`PO-20230615-0001`\n\n## 4. 自定义编号规则实现\n\n对于特殊业务需求，可以实现自定义的编号生成逻辑：\n\n```java\n/**\n * 生成自定义单据编号\n * @param document 单据实体\n * @throws Throwable 处理异常\n */\nprivate void generateCustomDocumentNumber(Document document) throws Throwable {\n    // 1. 获取编号规则配置\n    DocumentNumberRule rule = getDocumentNumberRule(document.getDocumentType());\n    \n    // 2. 构建编号前缀\n    StringBuilder prefix = new StringBuilder();\n    \n    // 添加模块前缀\n    prefix.append(rule.getModulePrefix());\n    \n    // 添加分隔符\n    if (rule.isUseSeparator()) {\n        prefix.append(rule.getSeparator());\n    }\n    \n    // 添加日期部分\n    if (rule.isIncludeDate()) {\n        SimpleDateFormat dateFormat = new SimpleDateFormat(rule.getDateFormat());\n        prefix.append(dateFormat.format(new Date()));\n        \n        // 添加分隔符\n        if (rule.isUseSeparator()) {\n            prefix.append(rule.getSeparator());\n        }\n    }\n    \n    // 3. 获取序号\n    int sequenceLength = rule.getSequenceLength();\n    long nextSequence = getNextSequence(rule.getSequenceKey());\n    \n    // 4. 格式化序号\n    String sequenceStr = String.format(\"%0\" + sequenceLength + \"d\", nextSequence);\n    \n    // 5. 组合完整编号\n    String documentNumber = prefix.toString() + sequenceStr;\n    \n    // 6. 设置编号到单据\n    document.setDocumentNumber(documentNumber);\n    logger.info(\"生成自定义单据编号: {}\", documentNumber);\n}\n```\n\n## 5. 序号生成与管理\n\n序号生成是单据编号的关键部分，需要确保序号的唯一性和连续性：\n\n```java\n/**\n * 获取下一个序号\n * @param sequenceKey 序号键\n * @return 下一个序号值\n * @throws Throwable 处理异常\n */\nprivate long getNextSequence(String sequenceKey) throws Throwable {\n    // 使用数据库序列或锁机制确保并发安全\n    synchronized (this) {\n        // 1. 查询当前序号\n        DocumentSequence sequence = (DocumentSequence) getMidContext().getObject(\n            DocumentSequence.class,\n            \"SequenceKey = ?\",\n            new Object[] { sequenceKey }\n        );\n        \n        // 2. 如果不存在则创建\n        if (sequence == null) {\n            sequence = new DocumentSequence();\n            sequence.setSequenceKey(sequenceKey);\n            sequence.setCurrentValue(0L);\n        }\n        \n        // 3. 增加序号值\n        long nextValue = sequence.getCurrentValue() + 1;\n        sequence.setCurrentValue(nextValue);\n        \n        // 4. 保存更新后的序号\n        getMidContext().saveObject(sequence);\n        \n        return nextValue;\n    }\n}\n```\n\n## 6. 按年月重置序号\n\n某些业务场景需要按年或按月重置序号：\n\n```java\n/**\n * 获取按月重置的序号\n * @param sequenceKey 序号基础键\n * @return 下一个序号值\n * @throws Throwable 处理异常\n */\nprivate long getMonthlySequence(String sequenceKey) throws Throwable {\n    // 1. 获取当前年月\n    Calendar calendar = Calendar.getInstance();\n    int year = calendar.get(Calendar.YEAR);\n    int month = calendar.get(Calendar.MONTH) + 1;\n    \n    // 2. 构建包含年月的序号键\n    String monthlyKey = String.format(\"%s_%d%02d\", sequenceKey, year, month);\n    \n    // 3. 获取该年月的序号\n    return getNextSequence(monthlyKey);\n}\n```\n\n## 7. 编号唯一性验证\n\n生成编号后，需要验证其唯一性：\n\n```java\n/**\n * 验证单据编号唯一性\n * @param documentNumber 单据编号\n * @param documentType 单据类型\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateDocumentNumberUnique(String documentNumber, String documentType) throws Throwable {\n    // 查询是否已存在相同编号\n    Object existingDoc = getMidContext().getObject(\n        Document.class,\n        \"DocumentNumber = ? AND DocumentType = ?\",\n        new Object[] { documentNumber, documentType }\n    );\n    \n    if (existingDoc != null) {\n        throw new Throwable(\"单据编号已存在: \" + documentNumber);\n    }\n}\n```\n\n## 8. 完整的单据编号生成流程\n\n在Formula类的save方法中，完整的单据编号生成流程如下：\n\n```java\n/**\n * 保存单据\n * @param document 单据实体\n * @return 单据ID\n * @throws Throwable 处理异常\n */\npublic Long save(Document document) throws Throwable {\n    logger.info(\"开始保存单据\");\n    \n    // 1. 验证必填字段\n    validateRequiredFields(document);\n    \n    // 2. 生成单据编号\n    if (document.getDocumentNumber() == null || document.getDocumentNumber().isEmpty()) {\n        // 根据业务需求选择编号生成方式\n        if (isUseCustomNumberRule(document.getDocumentType())) {\n            generateCustomDocumentNumber(document);\n        } else {\n            // 使用标准编号生成\n            String docNumber = DocumentFunction.generateDocumentNumber(\n                getMidContext(),\n                getModuleCode(document.getDocumentType()),\n                getDocumentTypeCode(document.getDocumentType())\n            );\n            document.setDocumentNumber(docNumber);\n        }\n    }\n    \n    // 3. 验证编号唯一性\n    validateDocumentNumberUnique(document.getDocumentNumber(), document.getDocumentType());\n    \n    // 4. 设置其他信息并保存\n    setDocumentBaseInfo(document);\n    Long objectID = getMidContext().saveObject(document);\n    \n    logger.info(\"单据保存完成，ID: {}, 编号: {}\", objectID, document.getDocumentNumber());\n    return objectID;\n}\n```\n\n## 9. 特殊编号规则处理\n\n对于特殊业务场景，可能需要更复杂的编号规则：\n\n```java\n/**\n * 生成包含业务信息的编号\n * @param document 单据实体\n * @throws Throwable 处理异常\n */\nprivate void generateBusinessInfoNumber(Document document) throws Throwable {\n    // 1. 基础前缀\n    StringBuilder number = new StringBuilder(\"PO\");\n    \n    // 2. 添加部门代码\n    Department dept = getDepartment(document.getDepartmentID());\n    if (dept != null && dept.getCode() != null) {\n        number.append(\"-\").append(dept.getCode());\n    }\n    \n    // 3. 添加日期信息\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyyMMdd\");\n    number.append(\"-\").append(dateFormat.format(new Date()));\n    \n    // 4. 添加供应商代码（适用于采购订单）\n    if (document instanceof PurchaseOrder) {\n        PurchaseOrder po = (PurchaseOrder) document;\n        Vendor vendor = getVendor(po.getVendorID());\n        if (vendor != null && vendor.getCode() != null) {\n            number.append(\"-\").append(vendor.getCode());\n        }\n    }\n    \n    // 5. 添加序号\n    String sequenceKey = \"PO_\" + dateFormat.format(new Date());\n    long sequence = getNextSequence(sequenceKey);\n    number.append(\"-\").append(String.format(\"%04d\", sequence));\n    \n    // 6. 设置编号\n    document.setDocumentNumber(number.toString());\n}\n```\n\n通过以上方法和规范，Formula类可以有效地处理单据编号生成，确保编号的唯一性、规范性和业务含义。这种实现方式符合ERP系统的业务需求，能够支持各种复杂的编号规则。"
},
{
"role": "user",
"content": "Formula类如何处理业务规则验证？"
},
{
"role": "assistant",
"content": "在ERP系统中，Formula类负责处理复杂的业务规则验证，确保业务数据的正确性和一致性。以下是Formula类处理业务规则验证的详细说明：\n\n## 1. 业务规则验证的基本原则\n\n业务规则验证应遵循以下基本原则：\n\n1. **完整性**：验证所有必要的业务规则\n2. **及时性**：在数据保存或状态变更前进行验证\n3. **明确性**：验证失败时提供清晰的错误信息\n4. **分层性**：将验证逻辑分为不同层次\n5. **可扩展性**：便于添加新的业务规则\n\n## 2. 验证方法的组织结构\n\n在Formula类中，通常将验证方法组织为以下结构：\n\n```java\n/**\n * 主验证方法 - 调用各类验证\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateDocument(Document document) throws Throwable {\n    // 1. 验证必填字段\n    validateRequiredFields(document);\n    \n    // 2. 验证数据格式和范围\n    validateDataFormat(document);\n    \n    // 3. 验证业务规则\n    validateBusinessRules(document);\n    \n    // 4. 验证关联数据\n    validateRelatedData(document);\n}\n```\n\n## 3. 必填字段验证\n\n```java\n/**\n * 验证必填字段\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateRequiredFields(Document document) throws Throwable {\n    // 验证主表必填字段\n    if (document.getDocumentDate() == null) {\n        throw new Throwable(\"单据日期不能为空\");\n    }\n    \n    if (document.getBusinessPartnerID() == null) {\n        throw new Throwable(\"业务伙伴不能为空\");\n    }\n    \n    // 验证明细表必填字段\n    List<DocumentItem> items = document.getItems();\n    if (items == null || items.isEmpty()) {\n        throw new Throwable(\"单据明细不能为空\");\n    }\n    \n    for (int i = 0; i < items.size(); i++) {\n        DocumentItem item = items.get(i);\n        if (item.getMaterialID() == null) {\n            throw new Throwable(String.format(\"第%d行物料不能为空\", i + 1));\n        }\n        \n        if (item.getQuantity() == null || item.getQuantity().compareTo(BigDecimal.ZERO) <= 0) {\n            throw new Throwable(String.format(\"第%d行数量必须大于0\", i + 1));\n        }\n    }\n}\n```\n\n## 4. 数据格式和范围验证\n\n```java\n/**\n * 验证数据格式和范围\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateDataFormat(Document document) throws Throwable {\n    // 验证日期范围\n    Date now = new Date();\n    if (document.getDocumentDate().after(now)) {\n        throw new Throwable(\"单据日期不能晚于当前日期\");\n    }\n    \n    // 验证编码格式\n    String code = document.getDocumentCode();\n    if (code != null && !code.matches(\"[A-Z0-9]{2,10}\")) {\n        throw new Throwable(\"单据编码格式不正确，应为2-10位大写字母和数字\");\n    }\n    \n    // 验证明细数据\n    List<DocumentItem> items = document.getItems();\n    for (DocumentItem item : items) {\n        // 验证数量精度\n        if (item.getQuantity() != null && hasInvalidPrecision(item.getQuantity(), 3)) {\n            throw new Throwable(\"数量精度不能超过3位小数\");\n        }\n        \n        // 验证金额精度\n        if (item.getAmount() != null && hasInvalidPrecision(item.getAmount(), 2)) {\n            throw new Throwable(\"金额精度不能超过2位小数\");\n        }\n    }\n}\n\n/**\n * 检查数值精度是否无效\n * @param value 数值\n * @param maxScale 最大小数位数\n * @return 是否无效\n */\nprivate boolean hasInvalidPrecision(BigDecimal value, int maxScale) {\n    return value.scale() > maxScale;\n}\n```\n\n## 5. 业务规则验证\n\n```java\n/**\n * 验证业务规则\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateBusinessRules(Document document) throws Throwable {\n    // 验证业务状态\n    validateBusinessStatus(document);\n    \n    // 验证业务限制\n    validateBusinessLimitations(document);\n    \n    // 验证业务一致性\n    validateBusinessConsistency(document);\n}\n\n/**\n * 验证业务状态\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateBusinessStatus(Document document) throws Throwable {\n    // 验证业务伙伴状态\n    BusinessPartner partner = getBusinessPartner(document.getBusinessPartnerID());\n    if (partner == null) {\n        throw new Throwable(\"业务伙伴不存在\");\n    }\n    \n    if (!partner.isActive()) {\n        throw new Throwable(\"业务伙伴已停用，不能创建新单据\");\n    }\n    \n    // 验证信用额度（采购订单示例）\n    if (document instanceof PurchaseOrder) {\n        BigDecimal creditLimit = partner.getCreditLimit();\n        BigDecimal currentUsed = getCurrentCreditUsed(partner.getOid());\n        BigDecimal orderAmount = document.getTotalAmount();\n        \n        if (creditLimit != null && creditLimit.compareTo(BigDecimal.ZERO) > 0 \n                && currentUsed.add(orderAmount).compareTo(creditLimit) > 0) {\n            throw new Throwable(\"超出信用额度限制，当前可用额度: \" \n                    + creditLimit.subtract(currentUsed));\n        }\n    }\n}\n\n/**\n * 验证业务限制\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateBusinessLimitations(Document document) throws Throwable {\n    // 验证预算限制\n    if (document instanceof PurchaseOrder) {\n        PurchaseOrder order = (PurchaseOrder) document;\n        Department dept = getDepartment(order.getDepartmentID());\n        \n        if (dept != null) {\n            BigDecimal budgetLimit = getBudgetLimit(dept.getOid(), new Date());\n            BigDecimal budgetUsed = getBudgetUsed(dept.getOid(), new Date());\n            BigDecimal orderAmount = order.getTotalAmount();\n            \n            if (budgetLimit != null && budgetLimit.compareTo(BigDecimal.ZERO) > 0 \n                    && budgetUsed.add(orderAmount).compareTo(budgetLimit) > 0) {\n                throw new Throwable(\"超出部门预算限制，当前可用预算: \" \n                        + budgetLimit.subtract(budgetUsed));\n            }\n        }\n    }\n    \n    // 验证数量限制\n    List<DocumentItem> items = document.getItems();\n    for (DocumentItem item : items) {\n        Material material = getMaterial(item.getMaterialID());\n        if (material != null && material.getMaxOrderQuantity() != null \n                && item.getQuantity().compareTo(material.getMaxOrderQuantity()) > 0) {\n            throw new Throwable(String.format(\"物料[%s]超出最大订购数量限制: %s\", \n                    material.getName(), material.getMaxOrderQuantity()));\n        }\n    }\n}\n\n/**\n * 验证业务一致性\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateBusinessConsistency(Document document) throws Throwable {\n    // 验证币种一致性\n    String currency = document.getCurrency();\n    List<DocumentItem> items = document.getItems();\n    \n    for (DocumentItem item : items) {\n        if (item.getCurrency() != null && !item.getCurrency().equals(currency)) {\n            throw new Throwable(String.format(\"明细行币种[%s]与单据币种[%s]不一致\", \n                    item.getCurrency(), currency));\n        }\n    }\n    \n    // 验证日期一致性\n    Date documentDate = document.getDocumentDate();\n    for (DocumentItem item : items) {\n        if (item.getDeliveryDate() != null && item.getDeliveryDate().before(documentDate)) {\n            throw new Throwable(\"明细行交货日期不能早于单据日期\");\n        }\n    }\n}\n```\n\n## 6. 关联数据验证\n\n```java\n/**\n * 验证关联数据\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateRelatedData(Document document) throws Throwable {\n    // 验证物料有效性\n    List<DocumentItem> items = document.getItems();\n    for (DocumentItem item : items) {\n        Material material = getMaterial(item.getMaterialID());\n        if (material == null) {\n            throw new Throwable(String.format(\"物料ID[%s]不存在\", item.getMaterialID()));\n        }\n        \n        if (!material.isActive()) {\n            throw new Throwable(String.format(\"物料[%s]已停用\", material.getName()));\n        }\n    }\n    \n    // 验证仓库有效性\n    if (document instanceof InventoryDocument) {\n        InventoryDocument invDoc = (InventoryDocument) document;\n        Warehouse warehouse = getWarehouse(invDoc.getWarehouseID());\n        \n        if (warehouse == null) {\n            throw new Throwable(String.format(\"仓库ID[%s]不存在\", invDoc.getWarehouseID()));\n        }\n        \n        if (!warehouse.isActive()) {\n            throw new Throwable(String.format(\"仓库[%s]已停用\", warehouse.getName()));\n        }\n    }\n}\n```\n\n## 7. 库存相关验证\n\n```java\n/**\n * 验证库存可用性\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateInventoryAvailability(InventoryDocument document) throws Throwable {\n    Long warehouseID = document.getWarehouseID();\n    List<InventoryDocumentItem> items = document.getItems();\n    \n    for (InventoryDocumentItem item : items) {\n        Long materialID = item.getMaterialID();\n        BigDecimal quantity = item.getQuantity();\n        \n        // 获取当前库存\n        BigDecimal currentStock = getAvailableStock(warehouseID, materialID);\n        \n        // 对于出库单据，验证库存是否足够\n        if (document.isOutbound() && currentStock.compareTo(quantity) < 0) {\n            Material material = getMaterial(materialID);\n            String materialName = material != null ? material.getName() : materialID.toString();\n            \n            throw new Throwable(String.format(\"物料[%s]库存不足，当前可用: %s, 需要: %s\", \n                    materialName, currentStock, quantity));\n        }\n    }\n}\n```\n\n## 8. 在业务方法中集成验证\n\n在Formula类的业务方法中，应该在适当的位置调用验证方法：\n\n```java\n/**\n * 保存单据\n * @param document 业务单据\n * @return 单据ID\n * @throws Throwable 处理异常\n */\npublic Long save(Document document) throws Throwable {\n    logger.info(\"开始保存单据\");\n    \n    // 1. 执行全面验证\n    validateDocument(document);\n    \n    // 2. 生成单据编号\n    generateDocumentNumber(document);\n    \n    // 3. 设置基本信息\n    setDocumentBaseInfo(document);\n    \n    // 4. 保存主表数据\n    Long objectID = getMidContext().saveObject(document);\n    document.setOid(objectID);\n    \n    // 5. 保存明细数据\n    saveDocumentItems(document);\n    \n    // 6. 更新状态\n    updateDocumentStatus(document, STATUS_DRAFT);\n    \n    logger.info(\"单据保存完成，ID: {}\", objectID);\n    return objectID;\n}\n\n/**\n * 提交单据\n * @param documentID 单据ID\n * @return 处理结果\n * @throws Throwable 处理异常\n */\npublic boolean submit(Long documentID) throws Throwable {\n    logger.info(\"开始提交单据，ID: {}\", documentID);\n    \n    // 1. 获取单据\n    Document document = getDocument(documentID);\n    \n    // 2. 验证当前状态\n    if (document.getStatus() != STATUS_DRAFT) {\n        throw new Throwable(\"只有草稿状态的单据可以提交\");\n    }\n    \n    // 3. 执行提交前验证\n    validateBeforeSubmit(document);\n    \n    // 4. 更新状态\n    updateDocumentStatus(document, STATUS_SUBMITTED);\n    \n    logger.info(\"单据提交完成，ID: {}\", documentID);\n    return true;\n}\n```\n\n## 9. 验证结果处理\n\n验证失败时，应提供清晰的错误信息，并记录日志：\n\n```java\n/**\n * 执行验证并处理结果\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void executeValidation(Document document) throws Throwable {\n    try {\n        // 执行验证\n        validateDocument(document);\n    } catch (Throwable e) {\n        // 记录验证失败日志\n        logger.error(\"单据验证失败: {}\", e.getMessage(), e);\n        \n        // 构建更详细的错误信息\n        StringBuilder errorMsg = new StringBuilder(\"验证失败: \");\n        errorMsg.append(e.getMessage());\n        \n        // 添加单据信息\n        if (document != null) {\n            errorMsg.append(\"\\n单据信息: 类型=\").append(document.getDocumentType());\n            if (document.getDocumentNumber() != null) {\n                errorMsg.append(\", 编号=\").append(document.getDocumentNumber());\n            }\n        }\n        \n        // 抛出带有详细信息的异常\n        throw new Throwable(errorMsg.toString(), e);\n    }\n}\n```\n\n通过以上方法和规范，Formula类可以有效地处理业务规则验证，确保业务数据的正确性和一致性。这种实现方式符合ERP系统的业务需求，能够支持各种复杂的业务规则验证场景。"
},
{
"role": "user",
"content": "Formula类如何处理事务和异常？"
},
{
"role": "assistant",
"content": "在ERP系统中，Formula类需要妥善处理事务和异常，以确保数据的一致性和系统的稳定性。以下是Formula类处理事务和异常的详细说明：\n\n## 1. 事务处理基本原则\n\n事务处理应遵循以下基本原则：\n\n1. **原子性(Atomicity)**：业务操作要么全部成功，要么全部失败\n2. **一致性(Consistency)**：事务执行前后，数据库保持一致状态\n3. **隔离性(Isolation)**：并发事务之间互不干扰\n4. **持久性(Durability)**：事务一旦提交，其结果永久保存\n\n## 2. Formula类中的事务处理\n\nFormula类通过继承`EntityContextAction`基类，自动获得事务处理能力。在ERP系统中，事务通常由上下文(Context)管理：\n\n```java\n/**\n * 执行事务性操作\n * @param document 业务单据\n * @return 处理结果ID\n * @throws Throwable 处理异常\n */\npublic Long executeInTransaction(Document document) throws Throwable {\n    logger.info(\"开始执行事务性操作\");\n    \n    // 获取上下文\n    IMidContext context = getMidContext();\n    \n    // 开始事务（通常由上下文自动管理）\n    // context.beginTransaction(); // 在某些实现中可能需要显式调用\n    \n    try {\n        // 1. 执行业务验证\n        validateDocument(document);\n        \n        // 2. 保存主表数据\n        Long objectID = context.saveObject(document);\n        document.setOid(objectID);\n        \n        // 3. 保存明细数据\n        saveDocumentItems(document);\n        \n        // 4. 更新相关数据\n        updateRelatedData(document);\n        \n        // 提交事务（通常由上下文自动管理）\n        // context.commitTransaction(); // 在某些实现中可能需要显式调用\n        \n        logger.info(\"事务性操作执行完成，ID: {}\", objectID);\n        return objectID;\n    } catch (Throwable e) {\n        // 回滚事务（通常由上下文自动管理）\n        // context.rollbackTransaction(); // 在某些实现中可能需要显式调用\n        \n        logger.error(\"事务性操作执行失败: {}\", e.getMessage(), e);\n        throw e; // 重新抛出异常，由上层处理\n    }\n}\n```\n\n## 3. 异常处理策略\n\nFormula类中的异常处理应遵循以下策略：\n\n1. **分类处理**：根据异常类型采取不同处理策略\n2. **信息增强**：为异常添加上下文信息，便于定位问题\n3. **日志记录**：记录详细的异常信息，便于排查\n4. **适当转换**：将底层异常转换为业务异常，对用户更友好\n\n```java\n/**\n * 处理业务操作并管理异常\n * @param documentID 单据ID\n * @return 处理结果\n * @throws BusinessException 业务异常\n */\npublic boolean processDocument(Long documentID) throws BusinessException {\n    logger.info(\"开始处理单据，ID: {}\", documentID);\n    \n    try {\n        // 1. 获取单据\n        Document document = getDocument(documentID);\n        \n        // 2. 执行业务操作\n        updateDocumentStatus(document, STATUS_PROCESSED);\n        processBusinessLogic(document);\n        \n        logger.info(\"单据处理完成，ID: {}\", documentID);\n        return true;\n    } catch (DataNotFoundException e) {\n        // 数据不存在异常处理\n        logger.error(\"单据不存在: {}\", documentID, e);\n        throw new BusinessException(\"单据不存在: \" + documentID, e);\n    } catch (ValidationException e) {\n        // 验证异常处理\n        logger.error(\"单据验证失败: {}\", e.getMessage(), e);\n        throw new BusinessException(\"单据验证失败: \" + e.getMessage(), e);\n    } catch (AuthorizationException e) {\n        // 权限异常处理\n        logger.error(\"权限不足: {}\", e.getMessage(), e);\n        throw new BusinessException(\"权限不足: \" + e.getMessage(), e);\n    } catch (Throwable e) {\n        // 其他未预期异常处理\n        logger.error(\"处理单据时发生未预期异常: {}\", e.getMessage(), e);\n        throw new BusinessException(\"系统处理异常，请联系管理员\", e);\n    }\n}\n```\n\n## 4. 自定义业务异常\n\n为了更好地表达业务含义，可以定义自定义业务异常：\n\n```java\n/**\n * 业务异常类\n */\npublic class BusinessException extends Exception {\n    private String errorCode;\n    private Object[] errorParams;\n    \n    /**\n     * 构造函数\n     * @param message 错误消息\n     */\n    public BusinessException(String message) {\n        super(message);\n    }\n    \n    /**\n     * 构造函数\n     * @param message 错误消息\n     * @param cause 原始异常\n     */\n    public BusinessException(String message, Throwable cause) {\n        super(message, cause);\n    }\n    \n    /**\n     * 构造函数\n     * @param errorCode 错误代码\n     * @param errorParams 错误参数\n     */\n    public BusinessException(String errorCode, Object[] errorParams) {\n        this.errorCode = errorCode;\n        this.errorParams = errorParams;\n    }\n    \n    // getter/setter方法\n}\n```\n\n## 5. 异常信息国际化\n\n为了支持多语言环境，可以实现异常信息的国际化：\n\n```java\n/**\n * 获取国际化的异常消息\n * @param exception 业务异常\n * @return 国际化后的消息\n */\nprivate String getLocalizedMessage(BusinessException exception) {\n    if (exception.getErrorCode() != null) {\n        // 使用消息资源获取国际化消息\n        return MessageResource.getMessage(\n            exception.getErrorCode(),\n            exception.getErrorParams()\n        );\n    } else {\n        // 使用异常原始消息\n        return exception.getMessage();\n    }\n}\n```\n\n## 6. 事务嵌套处理\n\n对于复杂业务场景，可能需要处理事务嵌套：\n\n```java\n/**\n * 在现有事务中执行操作\n * @param document 业务单据\n * @throws Throwable 处理异常\n */\nprivate void executeInExistingTransaction(Document document) throws Throwable {\n    // 检查是否已在事务中\n    boolean inTransaction = getMidContext().isInTransaction();\n    \n    if (inTransaction) {\n        // 已在事务中，直接执行操作\n        processInTransaction(document);\n    } else {\n        // 不在事务中，创建新事务\n        executeInTransaction(document);\n    }\n}\n```\n\n## 7. 事务隔离级别\n\n在某些特殊场景下，可能需要指定事务隔离级别：\n\n```java\n/**\n * 使用特定隔离级别执行事务\n * @param document 业务单据\n * @param isolationLevel 隔离级别\n * @return 处理结果ID\n * @throws Throwable 处理异常\n */\npublic Long executeWithIsolation(Document document, int isolationLevel) throws Throwable {\n    logger.info(\"开始执行特定隔离级别的事务操作\");\n    \n    // 获取上下文\n    IMidContext context = getMidContext();\n    \n    // 设置隔离级别并开始事务\n    // 注意：实际实现可能不同，这里仅为示例\n    // context.beginTransaction(isolationLevel);\n    \n    try {\n        // 执行业务操作\n        Long objectID = processInTransaction(document);\n        \n        // 提交事务\n        // context.commitTransaction();\n        \n        return objectID;\n    } catch (Throwable e) {\n        // 回滚事务\n        // context.rollbackTransaction();\n        throw e;\n    }\n}\n```\n\n## 8. 异常重试机制\n\n对于可能由于并发导致的临时性异常，可以实现重试机制：\n\n```java\n/**\n * 带重试机制的事务执行\n * @param document 业务单据\n * @return 处理结果ID\n * @throws Throwable 处理异常\n */\npublic Long executeWithRetry(Document document) throws Throwable {\n    final int MAX_RETRIES = 3;\n    final long RETRY_DELAY = 1000; // 毫秒\n    \n    int attempts = 0;\n    Throwable lastException = null;\n    \n    while (attempts < MAX_RETRIES) {\n        try {\n            attempts++;\n            return executeInTransaction(document);\n        } catch (ConcurrencyException e) {\n            // 只对并发异常进行重试\n            lastException = e;\n            logger.warn(\"执行遇到并发异常，准备第{}次重试: {}\", attempts, e.getMessage());\n            \n            // 延时后重试\n            if (attempts < MAX_RETRIES) {\n                Thread.sleep(RETRY_DELAY);\n            }\n        } catch (Throwable e) {\n            // 其他异常直接抛出，不重试\n            throw e;\n        }\n    }\n    \n    // 重试次数用尽，抛出最后一次异常\n    logger.error(\"重试{}次后仍然失败\", MAX_RETRIES);\n    throw lastException;\n}\n```\n\n## 9. 完整的事务和异常处理示例\n\n以下是一个完整的事务和异常处理示例，展示了在Formula类中如何处理复杂业务场景：\n\n```java\n/**\n * 执行完整的业务流程\n * @param documentID 单据ID\n * @return 处理结果\n * @throws BusinessException 业务异常\n */\npublic boolean executeBusinessProcess(Long documentID) throws BusinessException {\n    logger.info(\"开始执行业务流程，单据ID: {}\", documentID);\n    \n    try {\n        // 1. 获取单据\n        Document document = getDocument(documentID);\n        \n        // 2. 验证单据状态\n        if (document.getStatus() != STATUS_SUBMITTED) {\n            throw new ValidationException(\"只有已提交状态的单据可以处理\");\n        }\n        \n        // 3. 验证处理权限\n        validateProcessPermission(document);\n        \n        // 4. 在事务中执行主要业务逻辑\n        executeInTransaction(() -> {\n            try {\n                // 4.1 更新单据状态\n                updateDocumentStatus(document, STATUS_PROCESSING);\n                \n                // 4.2 处理主表数据\n                processMainDocument(document);\n                \n                // 4.3 处理明细数据\n                processDocumentItems(document);\n                \n                // 4.4 生成关联单据\n                generateRelatedDocuments(document);\n                \n                // 4.5 更新最终状态\n                updateDocumentStatus(document, STATUS_PROCESSED);\n                \n                return true;\n            } catch (Throwable e) {\n                // 事务内异常，将被外层捕获并回滚\n                throw new RuntimeException(e);\n            }\n        });\n        \n        // 5. 事务外的后续处理（即使前面失败也会执行）\n        try {\n            // 发送通知等非事务性操作\n            sendNotifications(document);\n        } catch (Throwable e) {\n            // 记录日志但不影响主流程结果\n            logger.error(\"发送通知失败: {}\", e.getMessage(), e);\n        }\n        \n        logger.info(\"业务流程执行完成，单据ID: {}\", documentID);\n        return true;\n    } catch (DataNotFoundException e) {\n        // 数据不存在异常\n        logger.error(\"单据不存在: {}\", documentID, e);\n        throw new BusinessException(\"E_DOCUMENT_NOT_FOUND\", new Object[]{documentID});\n    } catch (ValidationException e) {\n        // 验证异常\n        logger.error(\"单据验证失败: {}\", e.getMessage(), e);\n        throw new BusinessException(\"E_VALIDATION_FAILED\", new Object[]{e.getMessage()});\n    } catch (AuthorizationException e) {\n        // 权限异常\n        logger.error(\"权限不足: {}\", e.getMessage(), e);\n        throw new BusinessException(\"E_PERMISSION_DENIED\", new Object[]{e.getMessage()});\n    } catch (BusinessException e) {\n        // 已经是业务异常，直接抛出\n        logger.error(\"业务异常: {}\", e.getMessage(), e);\n        throw e;\n    } catch (Throwable e) {\n        // 其他未预期异常\n        logger.error(\"执行业务流程时发生未预期异常: {}\", e.getMessage(), e);\n        throw new BusinessException(\"E_SYSTEM_ERROR\", null, e);\n    }\n}\n\n/**\n * 在事务中执行操作\n * @param action 要执行的操作\n * @return 操作结果\n * @throws BusinessException 业务异常\n */\nprivate <T> T executeInTransaction(Callable<T> action) throws BusinessException {\n    // 获取上下文\n    IMidContext context = getMidContext();\n    \n    // 检查是否已在事务中\n    boolean startNewTransaction = !context.isInTransaction();\n    \n    try {\n        // 如果需要，开始新事务\n        if (startNewTransaction) {\n            // context.beginTransaction();\n            logger.debug(\"开始新事务\");\n        }\n        \n        // 执行业务操作\n        T result = action.call();\n        \n        // 如果是新事务，提交事务\n        if (startNewTransaction) {\n            // context.commitTransaction();\n            logger.debug(\"提交事务\");\n        }\n        \n        return result;\n    } catch (Throwable e) {\n        // 如果是新事务，回滚事务\n        if (startNewTransaction) {\n            try {\n                // context.rollbackTransaction();\n                logger.debug(\"回滚事务\");\n            } catch (Throwable rollbackEx) {\n                logger.error(\"回滚事务失败: {}\", rollbackEx.getMessage(), rollbackEx);\n            }\n        }\n        \n        // 转换并抛出业务异常\n        if (e instanceof BusinessException) {\n            throw (BusinessException) e;\n        } else {\n            throw new BusinessException(\"事务执行失败: \" + e.getMessage(), e);\n        }\n    }\n}\n```\n\n## 10. 分布式事务处理\n\n对于跨系统或跨服务的业务场景，可能需要处理分布式事务：\n\n```java\n/**\n * 处理分布式事务\n * @param document 业务单据\n * @return 处理结果\n * @throws BusinessException 业务异常\n */\npublic boolean processDistributedTransaction(Document document) throws BusinessException {\n    logger.info(\"开始处理分布式事务，单据ID: {}\", document.getOid());\n    \n    // 获取分布式事务管理器\n    DistributedTransactionManager txManager = getDistributedTransactionManager();\n    String txId = null;\n    \n    try {\n        // 1. 开始分布式事务\n        txId = txManager.begin();\n        logger.debug(\"开始分布式事务，事务ID: {}\", txId);\n        \n        // 2. 本地系统处理\n        boolean localResult = processLocalTransaction(document);\n        if (!localResult) {\n            throw new BusinessException(\"本地事务处理失败\");\n        }\n        \n        // 3. 调用外部系统A\n        boolean systemAResult = callExternalSystemA(document, txId);\n        if (!systemAResult) {\n            throw new BusinessException(\"外部系统A处理失败\");\n        }\n        \n        // 4. 调用外部系统B\n        boolean systemBResult = callExternalSystemB(document, txId);\n        if (!systemBResult) {\n            throw new BusinessException(\"外部系统B处理失败\");\n        }\n        \n        // 5. 提交分布式事务\n        txManager.commit(txId);\n        logger.debug(\"提交分布式事务，事务ID: {}\", txId);\n        \n        logger.info(\"分布式事务处理完成，单据ID: {}\", document.getOid());\n        return true;\n    } catch (Throwable e) {\n        // 回滚分布式事务\n        if (txId != null) {\n            try {\n                txManager.rollback(txId);\n                logger.debug(\"回滚分布式事务，事务ID: {}\", txId);\n            } catch (Throwable rollbackEx) {\n                logger.error(\"回滚分布式事务失败: {}\", rollbackEx.getMessage(), rollbackEx);\n            }\n        }\n        \n        logger.error(\"分布式事务处理失败: {}\", e.getMessage(), e);\n        throw new BusinessException(\"分布式事务处理失败: \" + e.getMessage(), e);\n    }\n}\n```\n\n## 11. 补偿事务处理\n\n对于无法使用强一致性事务的场景，可以实现补偿事务模式：\n\n```java\n/**\n * 使用补偿事务模式处理业务\n * @param document 业务单据\n * @return 处理结果\n * @throws BusinessException 业务异常\n */\npublic boolean processSagaTransaction(Document document) throws BusinessException {\n    logger.info(\"开始处理补偿事务，单据ID: {}\", document.getOid());\n    \n    // 记录已完成的步骤，用于补偿\n    List<String> completedSteps = new ArrayList<>();\n    \n    try {\n        // 1. 步骤1：处理本地数据\n        processLocalData(document);\n        completedSteps.add(\"LOCAL_DATA\");\n        \n        // 2. 步骤2：调用外部服务A\n        callServiceA(document);\n        completedSteps.add(\"SERVICE_A\");\n        \n        // 3. 步骤3：调用外部服务B\n        callServiceB(document);\n        completedSteps.add(\"SERVICE_B\");\n        \n        // 4. 步骤4：更新状态\n        updateFinalStatus(document);\n        completedSteps.add(\"FINAL_STATUS\");\n        \n        logger.info(\"补偿事务处理完成，单据ID: {}\", document.getOid());\n        return true;\n    } catch (Throwable e) {\n        // 执行补偿操作，按照完成步骤的相反顺序\n        logger.error(\"补偿事务处理失败，开始执行补偿操作: {}\", e.getMessage(), e);\n        \n        for (int i = completedSteps.size() - 1; i >= 0; i--) {\n            String step = completedSteps.get(i);\n            try {\n                compensateStep(document, step);\n                logger.debug(\"补偿步骤{}完成\", step);\n            } catch (Throwable compensateEx) {\n                logger.error(\"补偿步骤{}失败: {}\", step, compensateEx.getMessage(), compensateEx);\n                // 记录补偿失败，可能需要人工干预\n                recordCompensationFailure(document, step, compensateEx);\n            }\n        }\n        \n        throw new BusinessException(\"业务处理失败，已执行补偿操作: \" + e.getMessage(), e);\n    }\n}\n\n/**\n * 执行步骤补偿\n * @param document 业务单据\n * @param step 步骤标识\n * @throws Throwable 处理异常\n */\nprivate void compensateStep(Document document, String step) throws Throwable {\n    switch (step) {\n        case \"LOCAL_DATA\":\n            // 补偿本地数据处理\n            compensateLocalData(document);\n            break;\n        case \"SERVICE_A\":\n            // 补偿服务A调用\n            compensateServiceA(document);\n            break;\n        case \"SERVICE_B\":\n            // 补偿服务B调用\n            compensateServiceB(document);\n            break;\n        case \"FINAL_STATUS\":\n            // 补偿状态更新\n            compensateFinalStatus(document);\n            break;\n        default:\n            logger.warn(\"未知的补偿步骤: {}\", step);\n    }\n}\n```\n\n通过以上方法和规范，Formula类可以有效地处理事务和异常，确保业务数据的一致性和系统的稳定性。这种实现方式符合ERP系统的业务需求，能够支持各种复杂的业务场景，包括本地事务、分布式事务和补偿事务等。"
},
{
"role": "user",
"content": "Formula类如何与其他模块进行交互和通信？"
},
{
"role": "assistant",
"content": "在ERP系统中，Formula类需要与其他模块进行交互和通信，以实现跨模块的业务流程。以下是Formula类与其他模块交互和通信的详细说明：\n\n## 1. 模块间交互的基本原则\n\n模块间交互应遵循以下基本原则：\n\n1. **松耦合**：模块之间应保持松散耦合，减少直接依赖\n2. **标准接口**：通过标准接口进行交互，而非直接调用实现类\n3. **数据封装**：交互数据应适当封装，避免暴露内部实现细节\n4. **异常处理**：妥善处理跨模块调用可能产生的异常\n5. **事务一致**：确保跨模块操作的事务一致性\n\n## 2. 直接调用其他模块的Formula类\n\n最简单的交互方式是直接调用其他模块的Formula类：\n\n```java\n/**\n * 调用其他模块的Formula类\n * @param document 业务单据\n * @throws Throwable 处理异常\n */\nprivate void callOtherModuleFormula(Document document) throws Throwable {\n    // 获取上下文\n    IMidContext context = getMidContext();\n    \n    // 创建其他模块的Formula实例\n    InventoryFormula inventoryFormula = new InventoryFormula(context);\n    \n    // 调用其方法\n    Long inventoryDocID = inventoryFormula.createInventoryDoc(\n        document.getWarehouseID(),\n        document.getOid(),\n        \"MM_PurchaseOrder\",  // 来源单据类型\n        document.getItems()   // 明细数据\n    );\n    \n    // 处理返回结果\n    if (inventoryDocID != null) {\n        // 更新关联信息\n        document.setInventoryDocID(inventoryDocID);\n        context.saveObject(document);\n        \n        logger.info(\"创建库存单据成功，ID: {}\", inventoryDocID);\n    }\n}\n```\n\n## 3. 使用服务接口进行交互\n\n更规范的方式是通过服务接口进行交互：\n\n```java\n/**\n * 通过服务接口调用其他模块\n * @param document 业务单据\n * @throws Throwable 处理异常\n */\nprivate void callOtherModuleService(Document document) throws Throwable {\n    // 获取服务接口\n    IInventoryService inventoryService = ServiceLocator.getService(IInventoryService.class);\n    \n    // 准备调用参数\n    InventoryDocumentDTO dto = new InventoryDocumentDTO();\n    dto.setWarehouseID(document.getWarehouseID());\n    dto.setSourceID(document.getOid());\n    dto.setSourceType(\"MM_PurchaseOrder\");\n    dto.setItems(convertToInventoryItems(document.getItems()));\n    \n    // 调用服务方法\n    InventoryResultDTO result = inventoryService.createInventoryDocument(dto);\n    \n    // 处理返回结果\n    if (result.isSuccess()) {\n        // 更新关联信息\n        document.setInventoryDocID(result.getDocumentID());\n        getMidContext().saveObject(document);\n        \n        logger.info(\"通过服务接口创建库存单据成功，ID: {}\", result.getDocumentID());\n    } else {\n        // 处理错误\n        throw new BusinessException(\"创建库存单据失败: \" + result.getErrorMessage());\n    }\n}\n\n/**\n * 转换为库存明细项\n * @param items 单据明细\n * @return 库存明细项列表\n */\nprivate List<InventoryItemDTO> convertToInventoryItems(List<DocumentItem> items) {\n    List<InventoryItemDTO> inventoryItems = new ArrayList<>();\n    \n    for (DocumentItem item : items) {\n        InventoryItemDTO inventoryItem = new InventoryItemDTO();\n        inventoryItem.setMaterialID(item.getMaterialID());\n        inventoryItem.setQuantity(item.getQuantity());\n        inventoryItem.setUnitID(item.getUnitID());\n        // 设置其他属性...\n        \n        inventoryItems.add(inventoryItem);\n    }\n    \n    return inventoryItems;\n}\n```\n\n## 4. 使用事件机制进行通信\n\n对于松耦合的场景，可以使用事件机制进行通信：\n\n```java\n/**\n * 发布业务事件\n * @param document 业务单据\n * @throws Throwable 处理异常\n */\nprivate void publishBusinessEvent(Document document) throws Throwable {\n    // 创建事件对象\n    BusinessEvent event = new BusinessEvent();\n    event.setEventType(\"ORDER_APPROVED\");\n    event.setSourceModule(\"MM\");\n    event.setSourceType(\"PurchaseOrder\");\n    event.setSourceID(document.getOid());\n    event.setEventTime(new Date());\n    \n    // 设置事件数据\n    Map<String, Object> eventData = new HashMap<>();\n    eventData.put(\"documentNumber\", document.getDocumentNumber());\n    eventData.put(\"vendorID\", document.getVendorID());\n    eventData.put(\"totalAmount\", document.getTotalAmount());\n    // 设置其他需要的数据...\n    \n    event.setEventData(eventData);\n    \n    // 发布事件\n    EventPublisher publisher = EventPublisher.getInstance();\n    publisher.publishEvent(event);\n    \n    logger.info(\"发布业务事件: {}, 单据ID: {}\", event.getEventType(), document.getOid());\n}\n```\n\n## 5. 订阅和处理事件\n\n在Formula类中也可以订阅和处理其他模块发布的事件：\n\n```java\n/**\n * 事件处理类\n */\npublic class PurchaseOrderEventHandler implements EventHandler {\n    private static final Logger logger = LoggerFactory.getLogger(PurchaseOrderEventHandler.class);\n    \n    /**\n     * 处理事件\n     * @param event 业务事件\n     */\n    @Override\n    public void handleEvent(BusinessEvent event) {\n        try {\n            // 检查事件类型\n            if (\"INVENTORY_RECEIVED\".equals(event.getEventType())) {\n                // 处理库存接收事件\n                handleInventoryReceivedEvent(event);\n            } else if (\"PAYMENT_COMPLETED\".equals(event.getEventType())) {\n                // 处理付款完成事件\n                handlePaymentCompletedEvent(event);\n            }\n        } catch (Throwable e) {\n            logger.error(\"处理事件失败: {}\", e.getMessage(), e);\n        }\n    }\n    \n    /**\n     * 处理库存接收事件\n     * @param event 业务事件\n     * @throws Throwable 处理异常\n     */\n    private void handleInventoryReceivedEvent(BusinessEvent event) throws Throwable {\n        // 获取事件数据\n        Map<String, Object> eventData = event.getEventData();\n        Long sourceOrderID = (Long) eventData.get(\"sourceOrderID\");\n        String sourceType = (String) eventData.get(\"sourceType\");\n        \n        // 只处理与采购订单相关的事件\n        if (\"MM_PurchaseOrder\".equals(sourceType) && sourceOrderID != null) {\n            // 创建上下文\n            IMidContext context = ContextFactory.createContext();\n            \n            try {\n                // 创建Formula实例\n                PurchaseOrderFormula formula = new PurchaseOrderFormula(context);\n                \n                // 更新采购订单收货状态\n                formula.updateReceiptStatus(sourceOrderID);\n                \n                logger.info(\"处理库存接收事件完成，采购订单ID: {}\", sourceOrderID);\n            } finally {\n                // 释放上下文\n                if (context != null) {\n                    context.release();\n                }\n            }\n        }\n    }\n    \n    /**\n     * 处理付款完成事件\n     * @param event 业务事件\n     * @throws Throwable 处理异常\n     */\n    private void handlePaymentCompletedEvent(BusinessEvent event) throws Throwable {\n        // 实现类似的处理逻辑...\n    }\n}\n```\n\n## 6. 注册事件处理器\n\n事件处理器需要注册到事件系统：\n\n```java\n/**\n * 注册事件处理器\n */\npublic class MMEventHandlerRegistry implements IEventHandlerRegistry {\n    \n    /**\n     * 获取事件处理器列表\n     * @return 事件处理器数组\n     */\n    @Override\n    public EventHandler[] getEventHandlers() {\n        return new EventHandler[] {\n            new PurchaseOrderEventHandler(),\n            new MaterialEventHandler(),\n            // 其他事件处理器...\n        };\n    }\n}\n```\n\n## 7. 使用消息队列进行异步通信\n\n对于需要异步处理的场景，可以使用消息队列：\n\n```java\n/**\n * 发送异步消息\n * @param document 业务单据\n * @throws Throwable 处理异常\n */\nprivate void sendAsyncMessage(Document document) throws Throwable {\n    // 创建消息对象\n    BusinessMessage message = new BusinessMessage();\n    message.setMessageType(\"ORDER_CREATED\");\n    message.setSourceModule(\"MM\");\n    message.setSourceID(document.getOid());\n    message.setPriority(MessagePriority.NORMAL);\n    \n    // 设置消息内容\n    Map<String, Object> messageContent = new HashMap<>();\n    messageContent.put(\"documentNumber\", document.getDocumentNumber());\n    messageContent.put(\"documentDate\", document.getDocumentDate());\n    messageContent.put(\"totalAmount\", document.getTotalAmount());\n    // 设置其他需要的数据...\n    \n    message.setContent(messageContent);\n    \n    // 发送消息\n    MessageSender sender = MessageSender.getInstance();\n    sender.sendMessage(message);\n    \n    logger.info(\"发送异步消息: {}, 单据ID: {}\", message.getMessageType(), document.getOid());\n}\n```\n\n## 8. 处理异步消息\n\n在Formula类中也可以处理异步消息：\n\n```java\n/**\n * 消息处理类\n */\npublic class PurchaseOrderMessageHandler implements MessageHandler {\n    private static final Logger logger = LoggerFactory.getLogger(PurchaseOrderMessageHandler.class);\n    \n    /**\n     * 处理消息\n     * @param message 业务消息\n     * @return 处理结果\n     */\n    @Override\n    public boolean handleMessage(BusinessMessage message) {\n        try {\n            // 检查消息类型\n            if (\"INVENTORY_UPDATED\".equals(message.getMessageType())) {\n                // 处理库存更新消息\n                handleInventoryUpdatedMessage(message);\n                return true;\n            } else if (\"PRICE_CHANGED\".equals(message.getMessageType())) {\n                // 处理价格变更消息\n                handlePriceChangedMessage(message);\n                return true;\n            }\n            \n            // 不处理其他类型的消息\n            return false;\n        } catch (Throwable e) {\n            logger.error(\"处理消息失败: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n    \n    /**\n     * 处理库存更新消息\n     * @param message 业务消息\n     * @throws Throwable 处理异常\n     */\n    private void handleInventoryUpdatedMessage(BusinessMessage message) throws Throwable {\n        // 实现处理逻辑...\n    }\n    \n    /**\n     * 处理价格变更消息\n     * @param message 业务消息\n     * @throws Throwable 处理异常\n     */\n    private void handlePriceChangedMessage(BusinessMessage message) throws Throwable {\n        // 实现处理逻辑...\n    }\n}\n```\n\n## 9. 使用远程服务调用\n\n对于分布式部署的系统，可以使用远程服务调用：\n\n```java\n/**\n * 调用远程服务\n * @param document 业务单据\n * @throws Throwable 处理异常\n */\nprivate void callRemoteService(Document document) throws Throwable {\n    // 获取远程服务客户端\n    IRemoteServiceClient client = RemoteServiceClientFactory.createClient(\"FinanceService\");\n    \n    // 准备请求参数\n    Map<String, Object> parameters = new HashMap<>();\n    parameters.put(\"documentType\", \"PurchaseOrder\");\n    parameters.put(\"documentID\", document.getOid());\n    parameters.put(\"amount\", document.getTotalAmount());\n    parameters.put(\"currency\", document.getCurrency());\n    // 设置其他参数...\n    \n    // 调用远程服务\n    try {\n        Map<String, Object> result = client.invoke(\"createAccountingEntry\", parameters);\n        \n        // 处理返回结果\n        Boolean success = (Boolean) result.get(\"success\");\n        if (Boolean.TRUE.equals(success)) {\n            Long entryID = (Long) result.get(\"entryID\");\n            document.setAccountingEntryID(entryID);\n            getMidContext().saveObject(document);\n            \n            logger.info(\"调用远程服务创建会计分录成功，ID: {}\", entryID);\n        } else {\n            String errorMessage = (String) result.get(\"errorMessage\");\n            throw new BusinessException(\"创建会计分录失败: \" + errorMessage);\n        }\n    } catch (RemoteServiceException e) {\n        logger.error(\"调用远程服务失败: {}\", e.getMessage(), e);\n        throw new BusinessException(\"调用财务服务失败: \" + e.getMessage(), e);\n    }\n}\n```\n\n## 10. 使用数据集成接口\n\n对于需要数据集成的场景，可以使用专门的集成接口：\n\n```java\n/**\n * 通过数据集成接口与外部系统交互\n * @param document 业务单据\n * @throws Throwable 处理异常\n */\nprivate void integrateWithExternalSystem(Document document) throws Throwable {\n    // 获取集成接口\n    IDataIntegrationService integrationService = ServiceLocator.getService(IDataIntegrationService.class);\n    \n    // 准备集成数据\n    IntegrationData data = new IntegrationData();\n    data.setSourceSystem(\"ERP\");\n    data.setTargetSystem(\"CRM\");\n    data.setDataType(\"Order\");\n    data.setOperationType(\"Create\");\n    \n    // 设置业务数据\n    Map<String, Object> businessData = new HashMap<>();\n    businessData.put(\"orderNumber\", document.getDocumentNumber());\n    businessData.put(\"orderDate\", document.getDocumentDate());\n    businessData.put(\"customerID\", document.getBusinessPartnerID());\n    businessData.put(\"totalAmount\", document.getTotalAmount());\n    // 设置其他业务数据...\n    \n    data.setBusinessData(businessData);\n    \n    // 调用集成服务\n    IntegrationResult result = integrationService.sendData(data);\n    \n    // 处理返回结果\n    if (result.isSuccess()) {\n        // 更新集成状态\n        document.setIntegrationStatus(\"Integrated\");\n        document.setExternalSystemID(result.getExternalID());\n        getMidContext().saveObject(document);\n        \n        logger.info(\"数据集成成功，外部系统ID: {}\", result.getExternalID());\n    } else {\n        // 记录集成失败\n        document.setIntegrationStatus(\"Failed\");\n        document.setIntegrationError(result.getErrorMessage());\n        getMidContext().saveObject(document);\n        \n        logger.error(\"数据集成失败: {}\", result.getErrorMessage());\n        throw new BusinessException(\"与外部系统集成失败: \" + result.getErrorMessage());\n    }\n}\n```\n\n通过以上方法和规范，Formula类可以有效地与其他模块进行交互和通信，实现跨模块的业务流程。这种实现方式符合ERP系统的模块化设计原则，确保了系统的可扩展性和可维护性。"
}
]
}

