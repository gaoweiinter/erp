[
    {
      "messages": [
        {
          "role": "user",
          "content": "我需要为ERP系统添加一个新的库存管理功能，应该如何定义模块和包结构？"
        },
        {
          "role": "assistant",
          "content": "对于库存管理功能，你应该使用WM（Warehouse Management）作为模块标识。\n\n包结构应遵循以下规范：\n1. 基本包路径：`com.company.erp.wm`\n2. 内部结构：\n   - `com.company.erp.wm.entity` - 存放实体类\n   - `com.company.erp.wm.formula` - 存放业务逻辑处理类\n   - `com.company.erp.wm.registry` - 存放注册器类\n   - `com.company.erp.wm.common` - 存放公共组件\n\n这符合我们的分层架构设计，WM模块属于业务层(erp-supplychain-all)，需要依赖基础层(erp-basis-all)的功能。"
        },
        {
          "role": "user",
          "content": "库存管理相关的数据库表应该如何命名？"
        },
        {
          "role": "assistant",
          "content": "库存管理(WM)模块的数据库表命名应遵循以下规范：\n\n1. 模块表前缀：`EWM_`\n   - 例如：`EWM_StockHead` (库存主表)\n   - 例如：`EWM_StockMovement` (库存移动表)\n\n2. 模块缓存表前缀：`EGWM_`\n   - 例如：`EGWM_WarehouseConfig` (仓库配置缓存表)\n\n3. 表名示例：\n   - `EWM_InventoryHead` - 库存单据头表\n   - `EWM_InventoryItem` - 库存单据明细表\n   - `EWM_StockBalance` - 库存余额表\n   - `EGWM_LocationMaster` - 库位主数据缓存表\n\n记住，表名必须符合模块前缀规则，并使用英文名称准确描述表的业务用途。"
        },
        {
          "role": "user",
          "content": "我想开发一个库存移动的业务功能，Formula类应该如何设计？"
        },
        {
          "role": "assistant",
          "content": "库存移动功能的Formula类设计应遵循以下规范：\n\n```java\npackage com.company.erp.wm.formula;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.company.erp.function.EntityContextAction;\nimport com.company.erp.wm.entity.StockMovement;\n\npublic class StockMovementFormula extends EntityContextAction {\n    private static final Logger logger = LoggerFactory.getLogger(StockMovementFormula.class);\n\n    public StockMovementFormula(IMidContext context) throws Throwable {\n        super(context);\n    }\n    \n    /**\n     * 保存库存移动单据\n     * @param stockMovement 库存移动实体\n     * @return 保存后的实体ID\n     * @throws Throwable 处理异常\n     */\n    public Long save(StockMovement stockMovement) throws Throwable {\n        logger.info(\"开始保存库存移动单据\");\n        \n        // 1. 验证必填字段\n        validateRequiredFields(stockMovement);\n        \n        // 2. 生成单据编号\n        if (stockMovement.getDocumentNumber() == null) {\n            String docNumber = DocumentFunction.generateDocumentNumber(\n                getMidContext(),\n                \"WM\",     // 模块代码\n                \"SM\"      // 单据类型 StockMovement\n            );\n            stockMovement.setDocumentNumber(docNumber);\n        }\n        \n        // 3. 保存主表数据\n        Long objectID = getMidContext().saveObject(stockMovement);\n        \n        // 4. 保存明细数据（如果有）\n        saveDetails(stockMovement);\n        \n        // 5. 更新单据状态\n        StatusFormula statusFormula = new StatusFormula(getMidContext());\n        statusFormula.changeStatus(\n            true,\n            \"WM_StockMovement\",\n            \"SaveStockMovement\",\n            objectID,\n            getStatusProfileID(),\n            null\n        );\n        \n        logger.info(\"库存移动单据保存完成，ID: {}\", objectID);\n        return objectID;\n    }\n    \n    /**\n     * 验证必填字段\n     * @param stockMovement 库存移动实体\n     * @throws Throwable 验证失败抛出异常\n     */\n    private void validateRequiredFields(StockMovement stockMovement) throws Throwable {\n        if (stockMovement.getWarehouseID() == null) {\n            throw new Throwable(\"仓库不能为空\");\n        }\n        \n        if (stockMovement.getMoveDate() == null) {\n            throw new Throwable(\"移动日期不能为空\");\n        }\n        \n        // 其他业务验证...\n    }\n    \n    /**\n     * 保存明细数据\n     * @param stockMovement 库存移动实体\n     * @throws Throwable 处理异常\n     */\n    private void saveDetails(StockMovement stockMovement) throws Throwable {\n        // 明细数据保存逻辑...\n    }\n    \n    // 其他业务方法...\n}\n```\n\n同时，需要在WM模块的注册器中注册这个Formula类：\n\n```java\npackage com.company.erp.wm.registry;\n\nimport com.company.erp.function.IExtendContextActionRegistry;\nimport com.company.erp.wm.formula.StockMovementFormula;\n\npublic class WMContextActionRegistry implements IExtendContextActionRegistry {\n    @Override\n    public Class<?>[] getContextActions() {\n        Class<?>[] contextActions = new Class<?>[]{\n            StockMovementFormula.class,\n            // ... 其他WM模块Formula类\n        };\n        return contextActions;\n    }\n}\n```\n\n并确保在META-INF/services目录下的接口文件中添加注册器：\n```\ncom.company.erp.wm.registry.WMContextActionRegistry\n```"
        }
      ]
    },
    {
      "messages": [
        {
          "role": "user",
          "content": "如何设计ERP系统中的实体类？以采购订单为例。"
        },
        {
          "role": "assistant",
          "content": "在ERP系统中设计采购订单(PurchaseOrder)实体类应遵循以下规范：\n\n```java\npackage com.company.erp.mm.entity;\n\nimport java.math.BigDecimal;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * 采购订单实体类\n */\npublic class PurchaseOrder {\n    // 系统字段常量定义\n    public static final String FIELD_OID = \"OID\";\n    public static final String FIELD_SOID = \"SOID\";\n    public static final String FIELD_POID = \"POID\";\n    public static final String FIELD_STATUS = \"Status\";\n    \n    // 业务字段常量定义\n    public static final String FIELD_DOC_NUMBER = \"DocumentNumber\";\n    public static final String FIELD_VENDOR_ID = \"VendorID\";\n    public static final String FIELD_ORDER_DATE = \"OrderDate\";\n    public static final String FIELD_CURRENCY = \"Currency\";\n    public static final String FIELD_TOTAL_AMOUNT = \"TotalAmount\";\n    \n    // 系统字段\n    private Long oid;\n    private Long soid;\n    private Long poid;\n    private Integer status;\n    private Long creator;\n    private Date createTime;\n    private Long modifier;\n    private Date modifyTime;\n    \n    // 业务字段\n    private String documentNumber;\n    private Long vendorID;\n    private String vendorName;\n    private Date orderDate;\n    private String currency;\n    private BigDecimal totalAmount;\n    \n    // 明细列表（不持久化，仅用于传输）\n    private List<PurchaseOrderItem> items;\n    \n    // 构造函数\n    public PurchaseOrder() {\n    }\n    \n    // getter/setter方法（支持链式调用）\n    public Long getOid() {\n        return oid;\n    }\n    \n    public PurchaseOrder setOid(Long oid) {\n        this.oid = oid;\n        return this;\n    }\n    \n    public String getDocumentNumber() {\n        return documentNumber;\n    }\n    \n    public PurchaseOrder setDocumentNumber(String documentNumber) {\n        this.documentNumber = documentNumber;\n        return this;\n    }\n    \n    public Long getVendorID() {\n        return vendorID;\n    }\n    \n    public PurchaseOrder setVendorID(Long vendorID) {\n        this.vendorID = vendorID;\n        return this;\n    }\n    \n    // 其他getter/setter方法...\n}\n```\n\n该实体类设计遵循以下规范：\n1. 放在对应业务模块的entity包下（com.company.erp.mm.entity）\n2. 使用英文名称作为类名（PurchaseOrder）\n3. 字段常量定义为public static final\n4. getter/setter方法支持链式调用\n5. 包含系统字段和业务字段\n6. 包含适当的JavaDoc注释"
        },
        {
          "role": "user",
          "content": "采购订单明细实体类应该怎么设计？"
        },
        {
          "role": "assistant",
          "content": "采购订单明细(PurchaseOrderItem)实体类设计应遵循以下规范：\n\n```java\npackage com.company.erp.mm.entity;\n\nimport java.math.BigDecimal;\nimport java.util.Date;\n\n/**\n * 采购订单明细实体类\n */\npublic class PurchaseOrderItem {\n    // 系统字段常量定义\n    public static final String FIELD_OID = \"OID\";\n    public static final String FIELD_SOID = \"SOID\";\n    public static final String FIELD_POID = \"POID\";\n    \n    // 业务字段常量定义\n    public static final String FIELD_LINE_NUMBER = \"LineNumber\";\n    public static final String FIELD_MATERIAL_ID = \"MaterialID\";\n    public static final String FIELD_QUANTITY = \"Quantity\";\n    public static final String FIELD_UNIT_PRICE = \"UnitPrice\";\n    public static final String FIELD_AMOUNT = \"Amount\";\n    \n    // 系统字段\n    private Long oid;\n    private Long soid;  // 关联主表ID\n    private Long poid;\n    private Long creator;\n    private Date createTime;\n    private Long modifier;\n    private Date modifyTime;\n    \n    // 业务字段\n    private Integer lineNumber;  // 行号\n    private Long materialID;     // 物料ID\n    private String materialCode; // 物料编码\n    private String materialName; // 物料名称\n    private String unit;         // 单位\n    private BigDecimal quantity;  // 数量（精度：16,3）\n    private BigDecimal unitPrice; // 单价（精度：16,2）\n    private BigDecimal amount;    // 金额（精度：16,2）\n    private Date deliveryDate;   // 交货日期\n    private String remark;       // 备注\n    \n    // 构造函数\n    public PurchaseOrderItem() {\n    }\n    \n    // getter/setter方法（支持链式调用）\n    public Long getOid() {\n        return oid;\n    }\n    \n    public PurchaseOrderItem setOid(Long oid) {\n        this.oid = oid;\n        return this;\n    }\n    \n    public Long getSoid() {\n        return soid;\n    }\n    \n    public PurchaseOrderItem setSoid(Long soid) {\n        this.soid = soid;\n        return this;\n    }\n    \n    public Integer getLineNumber() {\n        return lineNumber;\n    }\n    \n    public PurchaseOrderItem setLineNumber(Integer lineNumber) {\n        this.lineNumber = lineNumber;\n        return this;\n    }\n    \n    public Long getMaterialID() {\n        return materialID;\n    }\n    \n    public PurchaseOrderItem setMaterialID(Long materialID) {\n        this.materialID = materialID;\n        return this;\n    }\n    \n    // 其他getter/setter方法...\n}\n```\n\n明细实体类设计要点：\n1. 放在与主表实体相同的包下（com.company.erp.mm.entity）\n2. 使用英文名称作为类名（PurchaseOrderItem）\n3. 包含关联主表ID的字段（soid）\n4. 包含行号字段（lineNumber）用于排序\n5. 包含数量、价格等关键业务字段，注意数值精度\n6. getter/setter方法支持链式调用\n7. 遵循统一的字段常量定义方式\n\n这种设计符合ERP系统的实体类标准，确保了实体类的一致性和可维护性。"
        },
        {
          "role": "user",
          "content": "如何在XML中定义采购订单的DataObject？"
        },
        {
          "role": "assistant",
          "content": "采购订单的DataObject XML定义应遵循以下规范：\n\n```xml\n<DataObject Key=\"MM_PurchaseOrder\" Caption=\"采购订单\" PrimaryTableKey=\"EMM_PurchaseOrderHead\" PrimaryType=\"Entity\" Version=\"1\">\n    <TableCollection>\n        <!-- 采购订单主表定义 -->\n        <Table Key=\"EMM_PurchaseOrderHead\" Caption=\"采购订单头表\" IndexPrefix=\"EMM_PurchaseOrderHead\">\n            <!-- 系统字段 -->\n            <Column Key=\"OID\" Caption=\"对象标识\" DataType=\"Long\" />\n            <Column Key=\"SOID\" Caption=\"主对象标识\" DataType=\"Long\" />\n            <Column Key=\"POID\" Caption=\"父对象标识\" DataType=\"Long\" />\n            <Column Key=\"VERID\" Caption=\"对象版本\" DataType=\"Integer\" />\n            <Column Key=\"Status\" Caption=\"状态\" DataType=\"Integer\" />\n            <Column Key=\"Creator\" Caption=\"制单人\" DataType=\"Long\" />\n            <Column Key=\"CreateTime\" Caption=\"制单时间\" DataType=\"DateTime\" />\n            <Column Key=\"Modifier\" Caption=\"修改人\" DataType=\"Long\" />\n            <Column Key=\"ModifyTime\" Caption=\"修改时间\" DataType=\"DateTime\" />\n            \n            <!-- 业务字段 -->\n            <Column Key=\"DocumentNumber\" Caption=\"采购订单号\" DataType=\"Varchar\" Length=\"20\" />\n            <Column Key=\"OrderDate\" Caption=\"订单日期\" DataType=\"DateTime\" />\n            <Column Key=\"VendorID\" Caption=\"供应商ID\" DataType=\"Long\" />\n            <Column Key=\"VendorCode\" Caption=\"供应商编码\" DataType=\"Varchar\" Length=\"20\" />\n            <Column Key=\"VendorName\" Caption=\"供应商名称\" DataType=\"Varchar\" Length=\"100\" />\n            <Column Key=\"PurchaserID\" Caption=\"采购员ID\" DataType=\"Long\" />\n            <Column Key=\"PurchaserName\" Caption=\"采购员\" DataType=\"Varchar\" Length=\"50\" />\n            <Column Key=\"DepartmentID\" Caption=\"部门ID\" DataType=\"Long\" />\n            <Column Key=\"DepartmentName\" Caption=\"部门\" DataType=\"Varchar\" Length=\"50\" />\n            <Column Key=\"Currency\" Caption=\"币种\" DataType=\"Varchar\" Length=\"10\" />\n            <Column Key=\"ExchangeRate\" Caption=\"汇率\" DataType=\"Numeric\" Precision=\"16\" Scale=\"6\" />\n            <Column Key=\"TotalAmount\" Caption=\"总金额\" DataType=\"Numeric\" Precision=\"16\" Scale=\"2\" />\n            <Column Key=\"DeliveryDate\" Caption=\"交货日期\" DataType=\"DateTime\" />\n            <Column Key=\"PaymentTerms\" Caption=\"付款条件\" DataType=\"Varchar\" Length=\"100\" />\n            <Column Key=\"Remark\" Caption=\"备注\" DataType=\"Varchar\" Length=\"500\" />\n        </Table>\n        \n        <!-- 采购订单明细表定义 -->\n        <Table Key=\"EMM_PurchaseOrderItem\" TableMode=\"Detail\" Caption=\"采购订单明细\" IndexPrefix=\"EMM_PurchaseOrderItem\">\n            <!-- 系统字段 -->\n            <Column Key=\"OID\" Caption=\"对象标识\" DataType=\"Long\" />\n            <Column Key=\"SOID\" Caption=\"主对象标识\" DataType=\"Long\" />\n            <Column Key=\"POID\" Caption=\"父对象标识\" DataType=\"Long\" />\n            <Column Key=\"VERID\" Caption=\"对象版本\" DataType=\"Integer\" />\n            <Column Key=\"Creator\" Caption=\"制单人\" DataType=\"Long\" />\n            <Column Key=\"CreateTime\" Caption=\"制单时间\" DataType=\"DateTime\" />\n            <Column Key=\"Modifier\" Caption=\"修改人\" DataType=\"Long\" />\n            <Column Key=\"ModifyTime\" Caption=\"修改时间\" DataType=\"DateTime\" />\n            \n            <!-- 业务字段 -->\n            <Column Key=\"LineNumber\" Caption=\"行号\" DataType=\"Integer\" />\n            <Column Key=\"MaterialID\" Caption=\"物料ID\" DataType=\"Long\" />\n            <Column Key=\"MaterialCode\" Caption=\"物料编码\" DataType=\"Varchar\" Length=\"50\" />\n            <Column Key=\"MaterialName\" Caption=\"物料名称\" DataType=\"Varchar\" Length=\"100\" />\n            <Column Key=\"Specification\" Caption=\"规格型号\" DataType=\"Varchar\" Length=\"100\" />\n            <Column Key=\"Unit\" Caption=\"单位\" DataType=\"Varchar\" Length=\"20\" />\n            <Column Key=\"Quantity\" Caption=\"数量\" DataType=\"Numeric\" Precision=\"16\" Scale=\"3\" />\n            <Column Key=\"UnitPrice\" Caption=\"单价\" DataType=\"Numeric\" Precision=\"16\" Scale=\"2\" />\n            <Column Key=\"Amount\" Caption=\"金额\" DataType=\"Numeric\" Precision=\"16\" Scale=\"2\" />\n            <Column Key=\"TaxRate\" Caption=\"税率\" DataType=\"Numeric\" Precision=\"16\" Scale=\"2\" />\n            <Column Key=\"TaxAmount\" Caption=\"税额\" DataType=\"Numeric\" Precision=\"16\" Scale=\"2\" />\n            <Column Key=\"DeliveryDate\" Caption=\"交货日期\" DataType=\"DateTime\" />\n            <Column Key=\"WarehouseID\" Caption=\"仓库ID\" DataType=\"Long\" />\n            <Column Key=\"WarehouseName\" Caption=\"仓库\" DataType=\"Varchar\" Length=\"50\" />\n            <Column Key=\"Remark\" Caption=\"备注\" DataType=\"Varchar\" Length=\"200\" />\n        </Table>\n    </TableCollection>\n</DataObject>\n```\n\nDataObject定义要点：\n\n1. DataObject命名规则：\n   - Key属性：`MM_PurchaseOrder`（模块_实体）\n   - PrimaryTableKey：`EMM_PurchaseOrderHead`（表前缀E + 模块标识MM + 实体名Head）\n\n2. 表命名规则：\n   - 主表Key：`EMM_PurchaseOrderHead`\n   - 明细表Key：`EMM_PurchaseOrderItem`\n   - 明细表需设置TableMode=\"Detail\"\n\n3. 系统字段：\n   - 包含必要的系统字段（OID, SOID, POID, VERID等）\n   - 包含创建/修改相关的审计字段\n\n4. 数据类型规范：\n   - 字符串：DataType=\"Varchar\" Length=\"长度值\"\n   - 整数：DataType=\"Integer\"\n   - 长整数：DataType=\"Long\"\n   - 数量小数：DataType=\"Numeric\" Precision=\"16\" Scale=\"3\"\n   - 金额小数：DataType=\"Numeric\" Precision=\"16\" Scale=\"2\"\n   - 日期时间：DataType=\"DateTime\"\n\n5. 索引前缀：与表Key保持一致\n\n该DataObject定义符合ERP系统的标准规范，确保了数据结构的一致性和可维护性。"
        }
      ]
    },
    {
      "messages": [
        {
          "role": "user",
          "content": "请解释一下ERP系统中Formula类的作用和开发规范。"
        },
        {
          "role": "assistant",
          "content": "在ERP系统中，Formula类是业务逻辑处理的核心组件，主要负责实现特定业务领域的功能逻辑。以下是Formula类的作用和开发规范：\n\n## Formula类的作用\n\n1. **业务逻辑封装**：将特定业务领域的逻辑封装在专门的Formula类中\n2. **状态管理**：负责管理业务对象的状态转换\n3. **数据验证**：执行业务规则验证和数据完整性检查\n4. **事务处理**：在业务上下文中执行事务性操作\n5. **业务流程控制**：控制业务处理流程，如审核、取消等\n\n## Formula类开发规范\n\n### 1. 基本结构\n\n```java\npublic class 业务Formula extends EntityContextAction {\n    private static final Logger logger = LoggerFactory.getLogger(业务Formula.class);\n\n    public 业务Formula(IMidContext context) throws Throwable {\n        super(context);\n    }\n\n    // 业务方法实现\n}\n```\n\n### 2. 命名规范\n- 命名规则：`实体名 + Formula`\n- 例如：`PurchaseOrderFormula`, `SalesOrderFormula`\n\n### 3. 包路径规范\n- 必须放在对应业务模块的formula包下\n- 例如：`com.company.erp.mm.formula.PurchaseOrderFormula`\n\n### 4. 继承关系\n- 必须继承`EntityContextAction`基类\n- 通过基类获取上下文和核心功能\n\n### 5. 构造函数\n- 必须包含接收`IMidContext`参数的构造函数\n- 必须处理异常（throws Throwable）\n\n### 6. 业务方法规范\n- 方法必须抛出Throwable异常\n- 必须包含日志记录\n- 必须进行参数验证\n- 必须进行权限检查\n- 必须维护单据状态\n\n### 7. 状态管理示例\n```java\n// 状态变更示例\nStatusFormula statusFormula = new StatusFormula(getMidContext());\nstatusFormula.changeStatus(\n    true,                   // 是否更新文档\n    \"业务对象类型\",          // 如：MM_PurchaseOrder\n    \"业务事务代码\",          // 如：SavePurchaseOrder\n    objectID,              // 对象ID\n    statusProfileID,       // 状态配置ID\n    statusInfo             // 状态信息\n);\n```\n\n### 8. 单据编号生成规范\n```java\n// 生成单据编号\nString docNumber = DocumentFunction.generateDocumentNumber(\n    getMidContext(),\n    \"MM\",     // 模块代码\n    \"PO\"      // 单据类型\n);\n```\n\n### 9. 模块注册\n- 每个Formula类必须在对应模块的ContextActionRegistry中注册\n- 通过SPI机制向系统注册Formula类\n\n遵循这些规范可以确保业务逻辑处理的一致性、可维护性和可扩展性，使ERP系统保持良好的架构特性。"
        },
        {
          "role": "user",
          "content": "能给我一个完整的采购订单Formula类实现示例吗？"
        },
        {
          "role": "assistant",
          "content": "以下是一个完整的采购订单(PurchaseOrder)Formula类实现示例：\n\n```java\npackage com.company.erp.mm.formula;\n\nimport java.math.BigDecimal;\nimport java.util.Date;\nimport java.util.List;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.company.erp.function.EntityContextAction;\nimport com.company.erp.function.DocumentFunction;\nimport com.company.erp.mm.entity.PurchaseOrder;\nimport com.company.erp.mm.entity.PurchaseOrderItem;\n\n/**\n * 采购订单业务逻辑处理类\n */\npublic class PurchaseOrderFormula extends EntityContextAction {\n    private static final Logger logger = LoggerFactory.getLogger(PurchaseOrderFormula.class);\n    \n    // 状态常量定义\n    public static final int STATUS_DRAFT = 10;        // 草稿\n    public static final int STATUS_SUBMITTED = 20;    // 已提交\n    public static final int STATUS_APPROVED = 30;     // 已审批\n    public static final int STATUS_CLOSED = 40;       // 已关闭\n    public static final int STATUS_CANCELED = 90;     // 已取消\n    \n    /**\n     * 构造函数\n     * @param context 上下文\n     * @throws Throwable 异常\n     */\n    public PurchaseOrderFormula(IMidContext context) throws Throwable {\n        super(context);\n    }\n    \n    /**\n     * 保存采购订单\n     * @param purchaseOrder 采购订单实体\n     * @return 采购订单ID\n     * @throws Throwable 处理异常\n     */\n    public Long save(PurchaseOrder purchaseOrder) throws Throwable {\n        logger.info(\"开始保存采购订单\");\n        \n        // 1. 验证必填字段\n        validateRequiredFields(purchaseOrder);\n        \n        // 2. 生成单据编号（如果没有）\n        if (purchaseOrder.getDocumentNumber() == null || purchaseOrder.getDocumentNumber().isEmpty()) {\n            String docNumber = DocumentFunction.generateDocumentNumber(\n                getMidContext(),\n                \"MM\",     // 模块代码\n                \"PO\"      // 单据类型（采购订单）\n            );\n            purchaseOrder.setDocumentNumber(docNumber);\n        }\n        \n        // 3. 设置创建/修改信息\n        Date now = new Date();\n        Long currentUserID = getCurrentUserID();\n        \n        if (purchaseOrder.getOid() == null) {\n            // 新建单据\n            purchaseOrder.setCreator(currentUserID)\n                         .setCreateTime(now)\n                         .setStatus(STATUS_DRAFT);\n        }\n        \n        purchaseOrder.setModifier(currentUserID)\n                     .setModifyTime(now);\n        \n        // 4. 保存主表数据\n        Long objectID = getMidContext().saveObject(purchaseOrder);\n        purchaseOrder.setOid(objectID);\n        \n        // 5. 处理明细数据\n        processOrderItems(purchaseOrder);\n        \n        // 6. 更新状态\n        updateOrderStatus(purchaseOrder, STATUS_DRAFT);\n        \n        logger.info(\"采购订单保存完成，ID: {}\", objectID);\n        return objectID;\n    }\n    \n    /**\n     * 提交采购订单\n     * @param orderID 采购订单ID\n     * @return 处理结果\n     * @throws Throwable 处理异常\n     */\n    public boolean submit(Long orderID) throws Throwable {\n        logger.info(\"开始提交采购订单，ID: {}\", orderID);\n        \n        // 1. 获取采购订单\n        PurchaseOrder order = getOrder(orderID);\n        \n        // 2. 验证当前状态\n        if (order.getStatus() != STATUS_DRAFT) {\n            throw new Throwable(\"只有草稿状态的采购订单可以提交\");\n        }\n        \n        // 3. 执行业务验证\n        validateOrderForSubmit(order);\n        \n        // 4. 更新状态\n        updateOrderStatus(order, STATUS_SUBMITTED);\n        \n        logger.info(\"采购订单提交完成，ID: {}\", orderID);\n        return true;\n    }\n    \n    /**\n     * 审批采购订单\n     * @param orderID 采购订单ID\n     * @return 处理结果\n     * @throws Throwable 处理异常\n     */\n    public boolean approve(Long orderID) throws Throwable {\n        logger.info(\"开始审批采购订单，ID: {}\", orderID);\n        \n        // 1. 获取采购订单\n        PurchaseOrder order = getOrder(orderID);\n        \n        // 2. 验证当前状态\n        if (order.getStatus() != STATUS_SUBMITTED) {\n            throw new Throwable(\"只有已提交状态的采购订单可以审批\");\n        }\n        \n        // 3. 执行业务验证\n        validateOrderForApprove(order);\n        \n        // 4. 更新状态\n        updateOrderStatus(order, STATUS_APPROVED);\n        \n        // 5. 执行审批后业务操作\n        processAfterApprove(order);\n        \n        logger.info(\"采购订单审批完成，ID: {}\", orderID);\n        return true;\n    }\n    \n    /**\n     * 取消采购订单\n     * @param orderID 采购订单ID\n     * @param cancelReason 取消原因\n     * @return 处理结果\n     * @throws Throwable 处理异常\n     */\n    public boolean cancel(Long orderID, String cancelReason) throws Throwable {\n        logger.info(\"开始取消采购订单，ID: {}\", orderID);\n        \n        // 1. 获取采购订单\n        PurchaseOrder order = getOrder(orderID);\n        \n        // 2. 验证当前状态\n        if (order.getStatus() == STATUS_CLOSED || order.getStatus() == STATUS_CANCELED) {\n            throw new Throwable(\"已关闭或已取消的采购订单不能再次取消\");\n        }\n        \n        // 3. 验证取消条件\n        validateOrderForCancel(order);\n        \n        // 4. 更新状态\n        updateOrderStatus(order, STATUS_CANCELED);\n        \n        // 5. 记录取消原因\n        saveOrderRemark(orderID, \"取消原因: \" + cancelReason);\n        \n        logger.info(\"采购订单取消完成，ID: {}\", orderID);\n        return true;\n    }\n    \n    /**\n     * 关闭采购订单\n     * @param orderID 采购订单ID\n     * @return 处理结果\n     * @throws Throwable 处理异常\n     */\n    public boolean close(Long orderID) throws Throwable {\n        logger.info(\"开始关闭采购订单，ID: {}\", orderID);\n        \n        // 1. 获取采购订单\n        PurchaseOrder order = getOrder(orderID);\n        \n        // 2. 验证当前状态\n        if (order.getStatus() != STATUS_APPROVED) {\n            throw new Throwable(\"只有已审批的采购订单可以关闭\");\n        }\n        \n        // 3. 验证关闭条件\n        validateOrderForClose(order);\n        \n        // 4. 更新状态\n        updateOrderStatus(order, STATUS_CLOSED);\n        \n        logger.info(\"采购订单关闭完成，ID: {}\", orderID);\n        return true;\n    }\n    \n    /**\n     * 获取采购订单\n     * @param orderID 采购订单ID\n     * @return 采购订单实体\n     * @throws Throwable 处理异常\n     */\n    private PurchaseOrder getOrder(Long orderID) throws Throwable {\n        if (orderID == null) {\n            throw new Throwable(\"采购订单ID不能为空\");\n        }\n        \n        PurchaseOrder order = (PurchaseOrder) getMidContext().getObject(PurchaseOrder.class, orderID);\n        if (order == null) {\n            throw new Throwable(\"采购订单不存在，ID: \" + orderID);\n        }\n        \n        return order;\n    }\n    \n    /**\n     * 验证必填字段\n     * @param purchaseOrder 采购订单实体\n     * @throws Throwable 验证失败抛出异常\n     */\n    private void validateRequiredFields(PurchaseOrder purchaseOrder) throws Throwable {\n        if (purchaseOrder == null) {\n            throw new Throwable(\"采购订单不能为空\");\n        }\n        \n        if (purchaseOrder.getVendorID() == null) {\n            throw new Throwable\n\n```java\n        if (purchaseOrder.getVendorID() == null) {\n            throw new Throwable(\"供应商不能为空\");\n        }\n        \n        if (purchaseOrder.getOrderDate() == null) {\n            throw new Throwable(\"订单日期不能为空\");\n        }\n        \n        if (purchaseOrder.getCurrency() == null || purchaseOrder.getCurrency().isEmpty()) {\n            throw new Throwable(\"币种不能为空\");\n        }\n        \n        // 验证明细数据\n        List<PurchaseOrderItem> items = purchaseOrder.getItems();\n        if (items == null || items.isEmpty()) {\n            throw new Throwable(\"采购订单明细不能为空\");\n        }\n        \n        // 验证明细行\n        for (int i = 0; i < items.size(); i++) {\n            PurchaseOrderItem item = items.get(i);\n            if (item.getMaterialID() == null) {\n                throw new Throwable(\"第\" + (i + 1) + \"行物料不能为空\");\n            }\n            \n            if (item.getQuantity() == null || item.getQuantity().compareTo(BigDecimal.ZERO) <= 0) {\n                throw new Throwable(\"第\" + (i + 1) + \"行数量必须大于0\");\n            }\n            \n            if (item.getUnitPrice() == null || item.getUnitPrice().compareTo(BigDecimal.ZERO) < 0) {\n                throw new Throwable(\"第\" + (i + 1) + \"行单价不能小于0\");\n            }\n        }\n    }\n    \n    /**\n     * 处理订单明细\n     * @param purchaseOrder 采购订单实体\n     * @throws Throwable 处理异常\n     */\n    private void processOrderItems(PurchaseOrder purchaseOrder) throws Throwable {\n        List<PurchaseOrderItem> items = purchaseOrder.getItems();\n        if (items == null || items.isEmpty()) {\n            return;\n        }\n        \n        // 删除旧明细数据\n        if (purchaseOrder.getOid() != null) {\n            getMidContext().deleteObjects(\n                PurchaseOrderItem.class,\n                \"SOID = ?\",\n                new Object[] { purchaseOrder.getOid() }\n            );\n        }\n        \n        // 保存新明细数据\n        BigDecimal totalAmount = BigDecimal.ZERO;\n        for (int i = 0; i < items.size(); i++) {\n            PurchaseOrderItem item = items.get(i);\n            \n            // 设置行号\n            item.setLineNumber(i + 1);\n            \n            // 设置关联主表ID\n            item.setSoid(purchaseOrder.getOid());\n            \n            // 计算行金额\n            if (item.getQuantity() != null && item.getUnitPrice() != null) {\n                BigDecimal amount = item.getQuantity().multiply(item.getUnitPrice());\n                item.setAmount(amount);\n                totalAmount = totalAmount.add(amount);\n            }\n            \n            // 保存明细行\n            getMidContext().saveObject(item);\n        }\n        \n        // 更新主表总金额\n        purchaseOrder.setTotalAmount(totalAmount);\n        getMidContext().saveObject(purchaseOrder);\n    }\n    \n    /**\n     * 更新订单状态\n     * @param order 采购订单实体\n     * @param status 目标状态\n     * @throws Throwable 处理异常\n     */\n    private void updateOrderStatus(PurchaseOrder order, int status) throws Throwable {\n        // 更新实体状态\n        order.setStatus(status);\n        getMidContext().saveObject(order);\n        \n        // 使用状态公式更新状态\n        StatusFormula statusFormula = new StatusFormula(getMidContext());\n        statusFormula.changeStatus(\n            true,\n            \"MM_PurchaseOrder\",\n            getStatusTransactionCode(status),\n            order.getOid(),\n            getStatusProfileID(),\n            null\n        );\n    }\n    \n    /**\n     * 获取状态事务代码\n     * @param status 状态值\n     * @return 状态事务代码\n     */\n    private String getStatusTransactionCode(int status) {\n        switch (status) {\n            case STATUS_DRAFT:\n                return \"SavePurchaseOrder\";\n            case STATUS_SUBMITTED:\n                return \"SubmitPurchaseOrder\";\n            case STATUS_APPROVED:\n                return \"ApprovePurchaseOrder\";\n            case STATUS_CLOSED:\n                return \"ClosePurchaseOrder\";\n            case STATUS_CANCELED:\n                return \"CancelPurchaseOrder\";\n            default:\n                return \"UnknownTransaction\";\n        }\n    }\n    \n    /**\n     * 获取状态配置ID\n     * @return 状态配置ID\n     */\n    private Long getStatusProfileID() {\n        // 实际应用中，可能从配置或上下文中获取\n        return 1000L;\n    }\n    \n    /**\n     * 获取当前用户ID\n     * @return 用户ID\n     */\n    private Long getCurrentUserID() {\n        // 实际应用中，从上下文中获取当前用户ID\n        return getMidContext().getCurrentUserID();\n    }\n    \n    /**\n     * 保存订单备注\n     * @param orderID 订单ID\n     * @param remark 备注内容\n     * @throws Throwable 处理异常\n     */\n    private void saveOrderRemark(Long orderID, String remark) throws Throwable {\n        // 实际应用中，可能保存到备注表或更新订单备注字段\n        PurchaseOrder order = getOrder(orderID);\n        order.setRemark(remark);\n        getMidContext().saveObject(order);\n    }\n    \n    /**\n     * 验证订单提交条件\n     * @param order 采购订单实体\n     * @throws Throwable 验证失败抛出异常\n     */\n    private void validateOrderForSubmit(PurchaseOrder order) throws Throwable {\n        // 业务验证逻辑\n        // 例如：验证金额、验证供应商状态等\n    }\n    \n    /**\n     * 验证订单审批条件\n     * @param order 采购订单实体\n     * @throws Throwable 验证失败抛出异常\n     */\n    private void validateOrderForApprove(PurchaseOrder order) throws Throwable {\n        // 业务验证逻辑\n        // 例如：验证审批权限、验证预算等\n    }\n    \n    /**\n     * 验证订单取消条件\n     * @param order 采购订单实体\n     * @throws Throwable 验证失败抛出异常\n     */\n    private void validateOrderForCancel(PurchaseOrder order) throws Throwable {\n        // 业务验证逻辑\n        // 例如：验证是否已有关联单据等\n    }\n    \n    /**\n     * 验证订单关闭条件\n     * @param order 采购订单实体\n     * @throws Throwable 验证失败抛出异常\n     */\n    private void validateOrderForClose(PurchaseOrder order) throws Throwable {\n        // 业务验证逻辑\n        // 例如：验证是否全部收货等\n    }\n    \n    /**\n     * 处理审批后业务操作\n     * @param order 采购订单实体\n     * @throws Throwable 处理异常\n     */\n    private void processAfterApprove(PurchaseOrder order) throws Throwable {\n        // 审批后业务处理\n        // 例如：生成库存预留、通知供应商等\n    }\n}\n```\n\n这个完整的PurchaseOrderFormula类实现了采购订单的全生命周期管理，包括：\n\n1. **基本结构**：继承EntityContextAction，包含必要的构造函数和日志定义\n2. **状态管理**：定义了采购订单的各种状态常量和状态转换方法\n3. **业务方法**：实现了保存、提交、审批、取消、关闭等核心业务功能\n4. **数据验证**：包含了必填字段验证、业务规则验证等\n5. **明细处理**：处理采购订单明细数据，包括行号设置、金额计算等\n6. **辅助方法**：提供了各种辅助功能，如获取订单、获取用户ID等\n\n这个实现符合ERP系统的Formula类开发规范，确保了业务逻辑的一致性和可维护性。"
      },
      {
        "role": "user",
        "content": "如何在模块注册器中注册这个Formula类？"
      },
      {
        "role": "assistant",
        "content": "在ERP系统中，每个Formula类都需要通过模块注册器(ContextActionRegistry)进行注册，才能被系统识别和使用。以下是在模块注册器中注册PurchaseOrderFormula类的完整步骤：\n\n## 1. 创建模块注册器类\n\n首先，需要在模块的registry包中创建一个注册器类，实现`IExtendContextActionRegistry`接口：\n\n```java\npackage com.company.erp.mm.registry;\n\nimport com.company.erp.function.IExtendContextActionRegistry;\nimport com.company.erp.mm.formula.PurchaseOrderFormula;\nimport com.company.erp.mm.formula.MaterialFormula;\n// 导入其他Formula类...\n\n/**\n * 物料管理模块注册器\n */\npublic class MMContextActionRegistry implements IExtendContextActionRegistry {\n    \n    /**\n     * 获取上下文动作类列表\n     * @return Formula类数组\n     */\n    @Override\n    public Class<?>[] getContextActions() {\n        // 返回所有需要注册的Formula类\n        Class<?>[] contextActions = new Class<?>[] {\n            PurchaseOrderFormula.class,\n            MaterialFormula.class,\n            // 其他MM模块的Formula类...\n        };\n        return contextActions;\n    }\n}\n```\n\n## 2. 通过SPI机制注册\n\n接下来，需要通过Java的SPI(Service Provider Interface)机制将注册器注册到系统中。在`resources/META-INF/services`目录下创建一个文件，文件名为接口的全限定名：\n\n```\nresources/\n└── META-INF/\n    └── services/\n        └── com.company.erp.function.IExtendContextActionRegistry\n```\n\n文件内容为注册器类的全限定名，每行一个：\n\n```\ncom.company.erp.mm.registry.MMContextActionRegistry\ncom.company.erp.sd.registry.SDContextActionRegistry\n# 其他模块的注册器...\n```\n\n## 3. 注册流程说明\n\n1. **创建注册器类**：每个业务模块(如MM、SD等)都需要创建一个对应的ContextActionRegistry类\n2. **实现接口方法**：实现`getContextActions()`方法，返回该模块所有Formula类的Class对象数组\n3. **创建SPI配置文件**：在META-INF/services目录下创建接口全限定名文件\n4. **添加注册器类名**：在SPI配置文件中添加注册器类的全限定名\n\n## 4. 注册维护规范\n\n在开发过程中，需要遵循以下规范维护注册器：\n\n1. **新增Formula类**：当新增Formula类时，必须同步更新对应模块的注册器，将新类添加到`getContextActions()`方法返回的数组中\n\n   ```java\n   @Override\n   public Class<?>[] getContextActions() {\n       return new Class<?>[] {\n           PurchaseOrderFormula.class,\n           MaterialFormula.class,\n           NewFormula.class,  // 新增的Formula类\n       };\n   }\n   ```\n\n2. **删除Formula类**：当删除Formula类时，必须从注册器中移除对应的Class对象\n\n3. **模块划分**：每个业务模块必须有自己的注册器，不同模块的Formula类不应混合注册\n\n4. **命名规范**：注册器类必须遵循`模块标识ContextActionRegistry`的命名规则\n\n5. **包路径规范**：注册器类必须放在模块的registry包下\n\n## 5. 完整示例\n\n以下是一个完整的MM模块注册器示例，包含了多个Formula类的注册：\n\n```java\npackage com.company.erp.mm.registry;\n\nimport com.company.erp.function.IExtendContextActionRegistry;\nimport com.company.erp.mm.formula.PurchaseOrderFormula;\nimport com.company.erp.mm.formula.MaterialFormula;\nimport com.company.erp.mm.formula.InventoryFormula;\nimport com.company.erp.mm.formula.VendorFormula;\nimport com.company.erp.mm.formula.GoodsReceiptFormula;\n\n/**\n * 物料管理模块注册器\n */\npublic class MMContextActionRegistry implements IExtendContextActionRegistry {\n    \n    /**\n     * 获取上下文动作类列表\n     * @return Formula类数组\n     */\n    @Override\n    public Class<?>[] getContextActions() {\n        Class<?>[] contextActions = new Class<?>[] {\n            // 采购相关\n            PurchaseOrderFormula.class,\n            PurchaseRequestFormula.class,\n            PurchaseContractFormula.class,\n            \n            // 物料相关\n            MaterialFormula.class,\n            MaterialGroupFormula.class,\n            \n            // 库存相关\n            InventoryFormula.class,\n            GoodsReceiptFormula.class,\n            GoodsIssueFormula.class,\n            \n            // 供应商相关\n            VendorFormula.class,\n            VendorEvaluationFormula.class\n        };\n        return contextActions;\n    }\n}\n```\n\n通过这种方式，系统可以在启动时自动加载所有注册的Formula类，使它们能够被调用执行业务逻辑。这种基于SPI的注册机制使得模块之间保持松耦合，同时确保了业务逻辑的可扩展性和可维护性。"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "Formula类中如何处理单据的审批流程？"
      },
      {
        "role": "assistant",
        "content": "在ERP系统中，Formula类处理单据审批流程需要遵循一系列规范和最佳实践。以下是处理审批流程的关键步骤和实现方法：\n\n## 1. 审批流程基本步骤\n\n审批流程通常包含以下基本步骤：\n\n1. **状态验证**：检查单据当前状态是否允许审批\n2. **权限验证**：验证当前用户是否有审批权限\n3. **业务规则验证**：验证单据是否满足审批条件\n4. **状态更新**：更新单据状态为已审批\n5. **后续处理**：执行审批后的业务操作\n\n## 2. 审批方法实现示例\n\n```java\n/**\n * 审批单据\n * @param documentID 单据ID\n * @param approveRemark 审批备注\n * @return 处理结果\n * @throws Throwable 处理异常\n */\npublic boolean approve(Long documentID, String approveRemark) throws Throwable {\n    logger.info(\"开始审批单据，ID: {}\", documentID);\n    \n    // 1. 获取单据\n    Document document = getDocument(documentID);\n    \n    // 2. 验证当前状态\n    if (document.getStatus() != STATUS_SUBMITTED) {\n        throw new Throwable(\"只有已提交状态的单据可以审批\");\n    }\n    \n    // 3. 验证审批权限\n    validateApprovePermission(document);\n    \n    // 4. 执行业务验证\n    validateDocumentForApprove(document);\n    \n    // 5. 更新状态\n    updateDocumentStatus(document, STATUS_APPROVED);\n    \n    // 6. 记录审批信息\n    saveApproveInfo(documentID, approveRemark);\n    \n    // 7. 执行审批后业务操作\n    processAfterApprove(document);\n    \n    logger.info(\"单据审批完成，ID: {}\", documentID);\n    return true;\n}\n```\n\n## 3. 权限验证实现\n\n```java\n/**\n * 验证审批权限\n * @param document 单据实体\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateApprovePermission(Document document) throws Throwable {\n    // 获取当前用户ID\n    Long currentUserID = getCurrentUserID();\n    \n    // 获取当前用户角色\n    List<String> userRoles = getUserRoles(currentUserID);\n    \n    // 检查是否有审批权限\n    boolean hasPermission = false;\n    \n    // 检查是否为审批人\n    if (document.getApproverID() != null && document.getApproverID().equals(currentUserID)) {\n        hasPermission = true;\n    }\n    \n    // 检查是否有审批角色\n    if (!hasPermission && userRoles.contains(\"APPROVER\")) {\n        hasPermission = true;\n    }\n    \n    // 检查是否有管理员角色\n    if (!hasPermission && userRoles.contains(\"ADMIN\")) {\n        hasPermission = true;\n    }\n    \n    if (!hasPermission) {\n        throw new Throwable(\"当前用户没有审批权限\");\n    }\n}\n```\n\n## 4. 状态管理实现\n\n```java\n/**\n * 更新单据状态\n * @param document 单据实体\n * @param status 目标状态\n * @throws Throwable 处理异常\n */\nprivate void updateDocumentStatus(Document document, int status) throws Throwable {\n    // 更新实体状态\n    document.setStatus(status);\n    getMidContext().saveObject(document);\n    \n    // 使用状态公式更新状态\n    StatusFormula statusFormula = new StatusFormula(getMidContext());\n    statusFormula.changeStatus(\n        true,                   // 是否更新文档\n        document.getDocumentType(),  // 单据类型\n        getStatusTransactionCode(status),  // 事务代码\n        document.getOid(),           // 对象ID\n        getStatusProfileID(),        // 状态配置ID\n        null                         // 状态信息\n    );\n    \n    // 记录状态变更日志\n    logStatusChange(document, status);\n}\n```\n\n## 5. 审批后处理实现\n\n```java\n/**\n * 处理审批后业务操作\n * @param document 单据实体\n * @throws Throwable 处理异常\n */\nprivate void processAfterApprove(Document document) throws Throwable {\n    // 1. 生成后续单据\n    generateFollowingDocuments(document);\n    \n    // 2. 更新相关业务数据\n    updateRelatedBusinessData(document);\n    \n    // 3. 发送通知\n    sendApprovalNotification(document);\n    \n    // 4. 触发其他业务流程\n    triggerBusinessProcess(document);\n}\n```\n\n## 6. 审批流程与工作流集成\n\n在更复杂的系统中，审批流程可能需要与工作流引擎集成：\n\n```java\n/**\n * 启动工作流审批流程\n * @param document 单据实体\n * @throws Throwable 处理异常\n */\nprivate void startWorkflowProcess(Document document) throws Throwable {\n    // 获取工作流引擎服务\n    WorkflowService workflowService = getWorkflowService();\n    \n    // 创建工作流参数\n    Map<String, Object> parameters = new HashMap<>();\n    parameters.put(\"documentID\", document.getOid());\n    parameters.put(\"documentType\", document.getDocumentType());\n    parameters.put(\"creatorID\", document.getCreator());\n    parameters.put(\"amount\", document.getTotalAmount());\n    \n    // 启动工作流程\n    String processInstanceID = workflowService.startProcess(\n        \"approvalProcess\",  // 流程定义ID\n        document.getOid().toString(),  // 业务键\n        parameters  // 流程参数\n    );\n    \n    // 保存流程实例ID到单据\n    document.setProcessInstanceID(processInstanceID);\n    getMidContext().saveObject(document);\n    \n    logger.info(\"启动审批工作流，单据ID: {}, 流程实例ID: {}\", document.getOid(), processInstanceID);\n}\n```\n\n## 7. 多级审批实现\n\n对于需要多级审批的场景，可以实现如下方法：\n\n```java\n/**\n * 处理多级审批\n * @param documentID 单据ID\n * @param approveLevel 审批级别\n * @param approveRemark 审批备注\n * @return 处理结果\n * @throws Throwable 处理异常\n */\npublic boolean approveByLevel(Long documentID, int approveLevel, String approveRemark) throws Throwable {\n    logger.info(\"开始{}级审批，单据ID: {}\", approveLevel, documentID);\n    \n    // 1. 获取单据\n    Document document = getDocument(documentID);\n    \n    // 2. 验证当前审批级别\n    int currentApproveLevel = document.getApproveLevel();\n    if (approveLevel != currentApproveLevel + 1) {\n        throw new Throwable(\"当前审批级别不正确，期望级别: \" + (currentApproveLevel + 1) + \", 实际级别: \" + approveLevel);\n    }\n    \n    // 3. 验证审批权限\n    validateApproveLevelPermission(document, approveLevel);\n    \n    // 4. 更新审批级别\n    document.setApproveLevel(approveLevel);\n    \n    // 5. 检查是否为最终审批\n    int maxApproveLevel = getMaxApproveLevel(document);\n    if (approveLevel >= maxApproveLevel) {\n        // 最终审批，更新状态为已审批\n        updateDocumentStatus(document, STATUS_APPROVED);\n        processAfterApprove(document);\n    } else {\n        // 中间审批，更新状态为审批中\n        updateDocumentStatus(document, STATUS_APPROVING);\n        // 通知下一级审批人\n        notifyNextApprover(document, approveLevel + 1);\n    }\n    \n    // 6. 记录审批信息\n    saveApproveLevelInfo(documentID, approveLevel, approveRemark);\n    \n    logger.info(\"{}级审批完成，单据ID: {}\", approveLevel, documentID);\n    return true;\n}\n```\n\n## 8. 审批历史记录\n\n```java\n/**\n * 保存审批信息\n * @param documentID 单据ID\n * @param approveRemark 审批备注\n * @throws Throwable 处理异常\n */\nprivate void saveApproveInfo(Long documentID, String approveRemark) throws Throwable {\n    // 创建审批历史记录\n    ApprovalHistory history = new ApprovalHistory();\n    history.setDocumentID(documentID)\n           .setApproverID(getCurrentUserID())\n           .setApproveTime(new Date())\n           .setApproveRemark(approveRemark);\n    \n    // 保存审批历史\n    getMidContext().saveObject(history);\n}\n```\n\n通过以上方法和规范，Formula类可以有效地处理单据的审批流程，确保业务流程的一致性、可追溯性和安全性。这种实现方式符合ERP系统的业务逻辑处理规范，能够满足企业级应用的审批需求。"
      },
      {
        "role": "user",
        "content": "Formula类如何处理单据编号生成？"
      },
      {
        "role": "assistant",
        "content": "在ERP系统中，单据编号是业务单据的重要标识，Formula类需要按照规范处理单据编号的生成。以下是Formula类处理单据编号生成的详细说明：\n\n## 1. 单据编号生成基本原则\n\n单据编号生成需要遵循以下基本原则：\n\n1. **唯一性**：系统内单据编号必须唯一\n2. **可读性**：编号应具有一定的业务含义\n3. **规范性**：遵循统一的编号规则\n4. **可追溯性**：能够反映业务信息（如日期、模块等）\n5. **连续性**：同类型单据编号应保持连续\n\n## 2. 使用DocumentFunction生成单据编号\n\n在Formula类中，通常使用系统提供的`DocumentFunction`工具类生成单据编号：\n\n```java\n/**\n * 生成单据编号\n * @param document 单据实体\n * @throws Throwable 处理异常\n */\nprivate void generateDocumentNumber(Document document) throws Throwable {\n    // 检查是否已有编号\n    if (document.getDocumentNumber() == null || document.getDocumentNumber().isEmpty()) {\n        // 使用DocumentFunction生成编号\n        String docNumber = DocumentFunction.generateDocumentNumber(\n            getMidContext(),\n            \"MM\",     // 模块代码\n            \"PO\"      // 单据类型\n        );\n        document.setDocumentNumber(docNumber);\n        logger.info(\"生成单据编号: {}\", docNumber);\n    }\n}\n```\n\n## 3. 编号规则配置\n\n单据编号规则通常在系统配置中定义，包括以下要素：\n\n1. **前缀**：通常包含模块代码和单据类型\n2. **日期部分**：年月日等时间信息\n3. **序号部分**：连续的数字序列\n4. **分隔符**：用于分隔各部分的字符\n\n例如，采购订单编号可能为：`PO-20230615-0001`\n\n## 4. 自定义编号规则实现\n\n对于特殊业务需求，可以实现自定义的编号生成逻辑：\n\n```java\n/**\n * 生成自定义单据编号\n * @param document 单据实体\n * @throws Throwable 处理异常\n */\nprivate void generateCustomDocumentNumber(Document document) throws Throwable {\n    // 1. 获取编号规则配置\n    DocumentNumberRule rule = getDocumentNumberRule(document.getDocumentType());\n    \n    // 2. 构建编号前缀\n    StringBuilder prefix = new StringBuilder();\n    \n    // 添加模块前缀\n    prefix.append(rule.getModulePrefix());\n    \n    // 添加分隔符\n    if (rule.isUseSeparator()) {\n        prefix.append(rule.getSeparator());\n    }\n    \n    // 添加日期部分\n    if (rule.isIncludeDate()) {\n        SimpleDateFormat dateFormat = new SimpleDateFormat(rule.getDateFormat());\n        prefix.append(dateFormat.format(new Date()));\n        \n        // 添加分隔符\n        if (rule.isUseSeparator()) {\n            prefix.append(rule.getSeparator());\n        }\n    }\n    \n    // 3. 获取序号\n    int sequenceLength = rule.getSequenceLength();\n    long nextSequence = getNextSequence(rule.getSequenceKey());\n    \n    // 4. 格式化序号\n    String sequenceStr = String.format(\"%0\" + sequenceLength + \"d\", nextSequence);\n    \n    // 5. 组合完整编号\n    String documentNumber = prefix.toString() + sequenceStr;\n    \n    // 6. 设置编号到单据\n    document.setDocumentNumber(documentNumber);\n    logger.info(\"生成自定义单据编号: {}\", documentNumber);\n}\n```\n\n## 5. 序号生成与管理\n\n序号生成是单据编号的关键部分，需要确保序号的唯一性和连续性：\n\n```java\n/**\n * 获取下一个序号\n * @param sequenceKey 序号键\n * @return 下一个序号值\n * @throws Throwable 处理异常\n */\nprivate long getNextSequence(String sequenceKey) throws Throwable {\n    // 使用数据库序列或锁机制确保并发安全\n    synchronized (this) {\n        // 1. 查询当前序号\n        DocumentSequence sequence = (DocumentSequence) getMidContext().getObject(\n            DocumentSequence.class,\n            \"SequenceKey = ?\",\n            new Object[] { sequenceKey }\n        );\n        \n        // 2. 如果不存在则创建\n        if (sequence == null) {\n            sequence = new DocumentSequence();\n            sequence.setSequenceKey(sequenceKey);\n            sequence.setCurrentValue(0L);\n        }\n        \n        // 3. 增加序号值\n        long nextValue = sequence.getCurrentValue() + 1;\n        sequence.setCurrentValue(nextValue);\n        \n        // 4. 保存更新后的序号\n        getMidContext().saveObject(sequence);\n        \n        return nextValue;\n    }\n}\n```\n\n## 6. 按年月重置序号\n\n某些业务场景需要按年或按月重置序号：\n\n```java\n/**\n * 获取按月重置的序号\n * @param sequenceKey 序号基础键\n * @return 下一个序号值\n * @throws Throwable 处理异常\n */\nprivate long getMonthlySequence(String sequenceKey) throws Throwable {\n    // 1. 获取当前年月\n    Calendar calendar = Calendar.getInstance();\n    int year = calendar.get(Calendar.YEAR);\n    int month = calendar.get(Calendar.MONTH) + 1;\n    \n    // 2. 构建包含年月的序号键\n    String monthlyKey = String.format(\"%s_%d%02d\", sequenceKey, year, month);\n    \n    // 3. 获取该年月的序号\n    return getNextSequence(monthlyKey);\n}\n```\n\n## 7. 编号唯一性验证\n\n生成编号后，需要验证其唯一性：\n\n```java\n/**\n * 验证单据编号唯一性\n * @param documentNumber 单据编号\n * @param documentType 单据类型\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateDocumentNumberUnique(String documentNumber, String documentType) throws Throwable {\n    // 查询是否已存在相同编号\n    Object existingDoc = getMidContext().getObject(\n        Document.class,\n        \"DocumentNumber = ? AND DocumentType = ?\",\n        new Object[] { documentNumber, documentType }\n    );\n    \n    if (existingDoc != null) {\n        throw new Throwable(\"单据编号已存在: \" + documentNumber);\n    }\n}\n```\n\n## 8. 完整的单据编号生成流程\n\n在Formula类的save方法中，完整的单据编号生成流程如下：\n\n```java\n/**\n * 保存单据\n * @param document 单据实体\n * @return 单据ID\n * @throws Throwable 处理异常\n */\npublic Long save(Document document) throws Throwable {\n    logger.info(\"开始保存单据\");\n    \n    // 1. 验证必填字段\n    validateRequiredFields(document);\n    \n    // 2. 生成单据编号\n    if (document.getDocumentNumber() == null || document.getDocumentNumber().isEmpty()) {\n        // 根据业务需求选择编号生成方式\n        if (isUseCustomNumberRule(document.getDocumentType())) {\n            generateCustomDocumentNumber(document);\n        } else {\n            // 使用标准编号生成\n            String docNumber = DocumentFunction.generateDocumentNumber(\n                getMidContext(),\n                getModuleCode(document.getDocumentType()),\n                getDocumentTypeCode(document.getDocumentType())\n            );\n            document.setDocumentNumber(docNumber);\n        }\n    }\n    \n    // 3. 验证编号唯一性\n    validateDocumentNumberUnique(document.getDocumentNumber(), document.getDocumentType());\n    \n    // 4. 设置其他信息并保存\n    setDocumentBaseInfo(document);\n    Long objectID = getMidContext().saveObject(document);\n    \n    logger.info(\"单据保存完成，ID: {}, 编号: {}\", objectID, document.getDocumentNumber());\n return objectID;\n}\n\n\n## 9. 特殊编号规则处理\n\n对于特殊业务场景，可能需要更复杂的编号规则：\n\njava\n/\n 生成包含业务信息的编号\n @param document 单据实体\n @throws Throwable 处理异常\n /\nprivate void generateBusinessInfoNumber(Document document) throws Throwable {\n // 1. 基础前缀\n StringBuilder number = new StringBuilder(\"PO\");\n \n // 2. 添加部门代码\n Department dept = getDepartment(document.getDepartmentID());\n if (dept != null && dept.getCode() != null) {\n number.append(\"-\").append(dept.getCode());\n }\n \n // 3. 添加日期信息\n SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyyMMdd\");\n number.append(\"-\").append(dateFormat.format(new Date()));\n \n // 4. 添加供应商代码（适用于采购订单）\n if (document instanceof PurchaseOrder) {\n PurchaseOrder po = (PurchaseOrder) document;\n Vendor vendor = getVendor(po.getVendorID());\n if (vendor != null && vendor.getCode() != null) {\n number.append(\"-\").append(vendor.getCode());\n }\n }\n \n // 5. 添加序号\n String sequenceKey = \"PO_\" + dateFormat.format(new Date());\n long sequence = getNextSequence(sequenceKey);\n number.append(\"-\").append(String.format(\"%04d\", sequence));\n \n // 6. 设置编号\n document.setDocumentNumber(number.toString());\n}\n\n\n通过以上方法和规范，Formula类可以有效地处理单据编号生成，确保编号的唯一性、规范性和业务含义。这种实现方式符合ERP系统的业务需求，能够支持各种复杂的编号规则。"
      },
      {
        "role": "user",
        "content": "Formula类如何处理业务规则验证？"
      },
      {
        "role": "assistant",
        "content": "在ERP系统中，Formula类负责处理复杂的业务规则验证，确保业务数据的正确性和一致性。以下是Formula类处理业务规则验证的详细说明：\n\n## 1. 业务规则验证的基本原则\n\n业务规则验证应遵循以下基本原则：\n\n1. **完整性**：验证所有必要的业务规则\n2. **及时性**：在数据保存或状态变更前进行验证\n3. **明确性**：验证失败时提供清晰的错误信息\n4. **分层性**：将验证逻辑分为不同层次\n5. **可扩展性**：便于添加新的业务规则\n\n## 2. 验证方法的组织结构\n\n在Formula类中，通常将验证方法组织为以下结构：\n\n```java\n/**\n * 主验证方法 - 调用各类验证\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateDocument(Document document) throws Throwable {\n    // 1. 验证必填字段\n    validateRequiredFields(document);\n    \n    // 2. 验证数据格式和范围\n    validateDataFormat(document);\n    \n    // 3. 验证业务规则\n    validateBusinessRules(document);\n    \n    // 4. 验证关联数据\n    validateRelatedData(document);\n}\n```\n\n## 3. 必填字段验证\n\n```java\n/**\n * 验证必填字段\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateRequiredFields(Document document) throws Throwable {\n    // 验证主表必填字段\n    if (document.getDocumentDate() == null) {\n        throw new Throwable(\"单据日期不能为空\");\n    }\n    \n    if (document.getBusinessPartnerID() == null) {\n        throw new Throwable(\"业务伙伴不能为空\");\n    }\n    \n    // 验证明细表必填字段\n    List<DocumentItem> items = document.getItems();\n    if (items == null || items.isEmpty()) {\n        throw new Throwable(\"单据明细不能为空\");\n    }\n    \n    for (int i = 0; i < items.size(); i++) {\n        DocumentItem item = items.get(i);\n        if (item.getMaterialID() == null) {\n            throw new Throwable(String.format(\"第%d行物料不能为空\", i + 1));\n        }\n        \n        if (item.getQuantity() == null || item.getQuantity().compareTo(BigDecimal.ZERO) <= 0) {\n            throw new Throwable(String.format(\"第%d行数量必须大于0\", i + 1));\n        }\n    }\n}\n```\n\n## 4. 数据格式和范围验证\n\n```java\n/**\n * 验证数据格式和范围\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateDataFormat(Document document) throws Throwable {\n    // 验证日期范围\n    Date now = new Date();\n    if (document.getDocumentDate().after(now)) {\n        throw new Throwable(\"单据日期不能晚于当前日期\");\n    }\n    \n    // 验证编码格式\n    String code = document.getDocumentCode();\n    if (code != null && !code.matches(\"[A-Z0-9]{2,10}\")) {\n        throw new Throwable(\"单据编码格式不正确，应为2-10位大写字母和数字\");\n    }\n    \n    // 验证明细数据\n    List<DocumentItem> items = document.getItems();\n    for (DocumentItem item : items) {\n        // 验证数量精度\n        if (item.getQuantity() != null && hasInvalidPrecision(item.getQuantity(), 3)) {\n            throw new Throwable(\"数量精度不能超过3位小数\");\n        }\n        \n        // 验证金额精度\n        if (item.getAmount() != null && hasInvalidPrecision(item.getAmount(), 2)) {\n            throw new Throwable(\"金额精度不能超过2位小数\");\n        }\n    }\n}\n\n/**\n * 检查数值精度是否无效\n * @param value 数值\n * @param maxScale 最大小数位数\n * @return 是否无效\n */\nprivate boolean hasInvalidPrecision(BigDecimal value, int maxScale) {\n    return value.scale() > maxScale;\n}\n```\n\n## 5. 业务规则验证\n\n```java\n/**\n * 验证业务规则\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateBusinessRules(Document document) throws Throwable {\n    // 验证业务状态\n    validateBusinessStatus(document);\n    \n    // 验证业务限制\n    validateBusinessLimitations(document);\n    \n    // 验证业务一致性\n    validateBusinessConsistency(document);\n}\n\n/**\n * 验证业务状态\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateBusinessStatus(Document document) throws Throwable {\n    // 验证业务伙伴状态\n    BusinessPartner partner = getBusinessPartner(document.getBusinessPartnerID());\n    if (partner == null) {\n        throw new Throwable(\"业务伙伴不存在\");\n    }\n    \n    if (!partner.isActive()) {\n        throw new Throwable(\"业务伙伴已停用，不能创建新单据\");\n    }\n    \n    // 验证信用额度（采购订单示例）\n    if (document instanceof PurchaseOrder) {\n        BigDecimal creditLimit = partner.getCreditLimit();\n        BigDecimal currentUsed = getCurrentCreditUsed(partner.getOid());\n        BigDecimal orderAmount = document.getTotalAmount();\n        \n        if (creditLimit != null && creditLimit.compareTo(BigDecimal.ZERO) > 0 \n                && currentUsed.add(orderAmount).compareTo(creditLimit) > 0) {\n            throw new Throwable(\"超出信用额度限制，当前可用额度: \" \n                    + creditLimit.subtract(currentUsed));\n        }\n    }\n}\n\n/**\n * 验证业务限制\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateBusinessLimitations(Document document) throws Throwable {\n    // 验证预算限制\n    if (document instanceof PurchaseOrder) {\n        PurchaseOrder order = (PurchaseOrder) document;\n        Department dept = getDepartment(order.getDepartmentID());\n        \n        if (dept != null) {\n            BigDecimal budgetLimit = getBudgetLimit(dept.getOid(), new Date());\n            BigDecimal budgetUsed = getBudgetUsed(dept.getOid(), new Date());\n            BigDecimal orderAmount = order.getTotalAmount();\n            \n            if (budgetLimit != null && budgetLimit.compareTo(BigDecimal.ZERO) > 0 \n                    && budgetUsed.add(orderAmount).compareTo(budgetLimit) > 0) {\n                throw new Throwable(\"超出部门预算限制，当前可用预算: \" \n                        + budgetLimit.subtract(budgetUsed));\n            }\n        }\n    }\n    \n    // 验证数量限制\n    List<DocumentItem> items = document.getItems();\n    for (DocumentItem item : items) {\n        Material material = getMaterial(item.getMaterialID());\n        if (material != null && material.getMaxOrderQuantity() != null \n                && item.getQuantity().compareTo(material.getMaxOrderQuantity()) > 0) {\n            throw new Throwable(String.format(\"物料[%s]超出最大订购数量限制: %s\", \n                    material.getName(), material.getMaxOrderQuantity()));\n        }\n    }\n}\n\n/**\n * 验证业务一致性\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateBusinessConsistency(Document document) throws Throwable {\n    // 验证币种一致性\n    String currency = document.getCurrency();\n    List<DocumentItem> items = document.getItems();\n    \n    for (DocumentItem item : items) {\n        if (item.getCurrency() != null && !item.getCurrency().equals(currency)) {\n            throw new Throwable(String.format(\"明细行币种[%s]与单据币种[%s]不一致\", \n                    item.getCurrency(), currency));\n        }\n    }\n    \n    // 验证日期一致性\n    Date documentDate = document.getDocumentDate();\n    for (DocumentItem item : items) {\n        if (item.getDeliveryDate() != null && item.getDeliveryDate().before(documentDate)) {\n            throw new Throwable(\"明细行交货日期不能早于单据日期\");\n        }\n    }\n}\n```\n\n## 6. 关联数据验证\n\n```java\n/**\n * 验证关联数据\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateRelatedData(Document document) throws Throwable {\n    // 验证物料有效性\n    List<DocumentItem> items = document.getItems();\n    for (DocumentItem item : items) {\n        Material material = getMaterial(item.getMaterialID());\n        if (material == null) {\n            throw new Throwable(String.format(\"物料ID[%s]不存在\", item.getMaterialID()));\n        }\n        \n        if (!material.isActive()) {\n            throw new Throwable(String.format(\"物料[%s]已停用\", material.getName()));\n        }\n    }\n    \n    // 验证仓库有效性\n    if (document instanceof InventoryDocument) {\n        InventoryDocument invDoc = (InventoryDocument) document;\n        Warehouse warehouse = getWarehouse(invDoc.getWarehouseID());\n        \n        if (warehouse == null) {\n            throw new Throwable(String.format(\"仓库ID[%s]不存在\", invDoc.getWarehouseID()));\n        }\n        \n        if (!warehouse.isActive()) {\n            throw new Throwable(String.format(\"仓库[%s]已停用\", warehouse.getName()));\n        }\n    }\n}\n```\n\n## 7. 库存相关验证\n\n```java\n/**\n * 验证库存可用性\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateInventoryAvailability(InventoryDocument document) throws Throwable {\n    Long warehouseID = document.getWarehouseID();\n    List<InventoryDocumentItem> items = document.getItems();\n    \n    for (InventoryDocumentItem item : items) {\n        Long materialID = item.getMaterialID();\n        BigDecimal quantity = item.getQuantity();\n        \n        // 获取当前库存\n        BigDecimal currentStock = getAvailableStock(warehouseID, materialID);\n        \n        // 对于出库单据，验证库存是否足够\n        if (document.isOutbound() && currentStock.compareTo(quantity) < 0) {\n            Material material = getMaterial(materialID);\n            String materialName = material != null ? material.getName() : materialID.toString();\n            \n            throw new Throwable(String.format(\"物料[%s]库存不足，当前可用: %s, 需要: %s\", \n                    materialName, currentStock, quantity));\n        }\n    }\n}\n```\n\n## 8. 在业务方法中集成验证\n\n在Formula类的业务方法中，应该在适当的位置调用验证方法：\n\n```java\n/**\n * 保存单据\n * @param document 业务单据\n * @return 单据ID\n * @throws Throwable 处理异常\n */\npublic Long save(Document document) throws Throwable {\n    logger.info(\"开始保存单据\");\n    \n    // 1. 执行全面验证\n    validateDocument(document);\n    \n    // 2. 生成单据编号\n    generateDocumentNumber(document);\n    \n    // 3. 设置基本信息\n    setDocumentBaseInfo(document);\n    \n    // 4. 保存主表数据\n    Long objectID = getMidContext().saveObject(document);\n    document.setOid(objectID);\n    \n    // 5. 保存明细数据\n    saveDocumentItems(document);\n    \n    // 6. 更新状态\n    updateDocumentStatus(document, STATUS_DRAFT);\n    \n    logger.info(\"单据保存完成，ID: {}\", objectID);\n    return objectID;\n}\n\n/**\n * 提交单据\n * @param documentID 单据ID\n * @return 处理结果\n * @throws Throwable 处理异常\n */\npublic boolean submit(Long documentID) throws Throwable {\n    logger.info(\"开始提交单据，ID: {}\", documentID);\n    \n    // 1. 获取单据\n    Document document = getDocument(documentID);\n    \n    // 2. 验证当前状态\n    if (document.getStatus() != STATUS_DRAFT) {\n        throw new Throwable(\"只有草稿状态的单据可以提交\");\n    }\n    \n    // 3. 执行提交前验证\n    validateBeforeSubmit(document);\n    \n    // 4. 更新状态\n    updateDocumentStatus(document, STATUS_SUBMITTED);\n    \n    logger.info(\"单据提交完成，ID: {}\", documentID);\n    return true;\n}\n```\n\n## 9. 验证结果处理\n\n验证失败时，应提供清晰的错误信息，并记录日志：\n\n```java\n/**\n * 执行验证并处理结果\n * @param document 业务单据\n * @throws Throwable 验证失败抛出异常\n */\nprivate void executeValidation(Document document) throws Throwable {\n    try {\n        // 执行验证\n        validateDocument(document);\n    } catch (Throwable e) {\n        // 记录验证失败日志\n        logger.error(\"单据验证失败: {}\", e.getMessage(), e);\n        \n        // 构建更详细的错误信息\n        StringBuilder errorMsg = new StringBuilder(\"验证失败: \");\n        errorMsg.append(e.getMessage());\n        \n        // 添加单据信息\n        if (document != null) {\n            errorMsg.append(\"\\n单据信息: 类型=\").append(document.getDocumentType());\n            if (document.getDocumentNumber() != null) {\n                errorMsg.append(\", 编号=\").append(document.getDocumentNumber());\n            }\n        }\n        \n        // 抛出带有详细信息的异常\n        throw new Throwable(errorMsg.toString(), e);\n    }\n}\n```\n\n通过以上方法和规范，Formula类可以有效地处理业务规则验证，确保业务数据的正确性和一致性。这种实现方式符合ERP系统的业务需求，能够支持各种复杂的业务规则验证场景。"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "Formula类如何处理事务和异常？"
      },
      {
        "role": "assistant",
        "content": "在ERP系统中，Formula类需要妥善处理事务和异常，以确保数据的一致性和系统的稳定性。以下是Formula类处理事务和异常的详细说明：\n\n## 1. 事务处理基本原则\n\n事务处理应遵循以下基本原则：\n\n1. **原子性(Atomicity)**：业务操作要么全部成功，要么全部失败\n2. **一致性(Consistency)**：事务执行前后，数据库保持一致状态\n3. **隔离性(Isolation)**：并发事务之间互不干扰\n4. **持久性(Durability)**：事务一旦提交，其结果永久保存\n\n## 2. Formula类中的事务处理\n\nFormula类通过继承`EntityContextAction`基类，自动获得事务处理能力。在ERP系统中，事务通常由上下文(Context)管理：\n\n```java\n/**\n * 执行事务性操作\n * @param document 业务单据\n * @return 处理结果ID\n * @throws Throwable 处理异常\n */\npublic Long executeInTransaction(Document document) throws Throwable {\n    logger.info(\"开始执行事务性操作\");\n    \n    // 获取上下文\n    IMidContext context = getMidContext();\n    \n    // 开始事务（通常由上下文自动管理）\n    // context.beginTransaction(); // 在某些实现中可能需要显式调用\n    \n    try {\n        // 1. 执行业务验证\n        validateDocument(document);\n        \n        // 2. 保存主表数据\n        Long objectID = context.saveObject(document);\n        document.setOid(objectID);\n        \n        // 3. 保存明细数据\n        saveDocumentItems(document);\n        \n        // 4. 更新相关数据\n        updateRelatedData(document);\n        \n        // 提交事务（通常由上下文自动管理）\n        // context.commitTransaction(); // 在某些实现中可能需要显式调用\n        \n        logger.info(\"事务性操作执行完成，ID: {}\", objectID);\n        return objectID;\n    } catch (Throwable e) {\n        // 回滚事务（通常由上下文自动管理）\n        // context.rollbackTransaction(); // 在某些实现中可能需要显式调用\n        \n        logger.error(\"事务性操作执行失败: {}\", e.getMessage(), e);\n        throw e; // 重新抛出异常，由上层处理\n    }\n}\n```\n\n## 3. 异常处理策略\n\nFormula类中的异常处理应遵循以下策略：\n\n1. **分类处理**：根据异常类型采取不同处理策略\n2. **信息增强**：为异常添加上下文信息，便于定位问题\n3. **日志记录**：记录详细的异常信息，便于排查\n4. **适当转换**：将底层异常转换为业务异常，对用户更友好\n\n```java\n/**\n * 处理业务操作并管理异常\n * @param documentID 单据ID\n * @return 处理结果\n * @throws BusinessException 业务异常\n */\npublic boolean processDocument(Long documentID) throws BusinessException {\n    logger.info(\"开始处理单据，ID: {}\", documentID);\n    \n    try {\n        // 1. 获取单据\n        Document document = getDocument(documentID);\n        \n        // 2. 执行业务操作\n        updateDocumentStatus(document, STATUS_PROCESSED);\n        processBusinessLogic(document);\n        \n        logger.info(\"单据处理完成，ID: {}\", documentID);\n        return true;\n    } catch (DataNotFoundException e) {\n        // 数据不存在异常处理\n        logger.error(\"单据不存在: {}\", documentID, e);\n        throw new BusinessException(\"单据不存在: \" + documentID, e);\n    } catch (ValidationException e) {\n        // 验证异常处理\n        logger.error(\"单据验证失败: {}\", e.getMessage(), e);\n        throw new BusinessException(\"单据验证失败: \" + e.getMessage(), e);\n    } catch (AuthorizationException e) {\n        // 权限异常处理\n        logger.error(\"权限不足: {}\", e.getMessage(), e);\n        throw new BusinessException(\"权限不足: \" + e.getMessage(), e);\n    } catch (Throwable e) {\n        // 其他未预期异常处理\n        logger.error(\"处理单据时发生未预期异常: {}\", e.getMessage(), e);\n        throw new BusinessException(\"系统处理异常，请联系管理员\", e);\n    }\n}\n```\n\n## 4. 自定义业务异常\n\n为了更好地表达业务含义，可以定义自定义业务异常：\n\n```java\n/**\n * 业务异常类\n */\npublic class BusinessException extends Exception {\n    private String errorCode;\n    private Object[] errorParams;\n    \n    /**\n     * 构造函数\n     * @param message 错误消息\n     */\n    public BusinessException(String message) {\n        super(message);\n    }\n    \n    /**\n     * 构造函数\n     * @param message 错误消息\n     * @param cause 原始异常\n     */\n    public BusinessException(String message, Throwable cause) {\n        super(message, cause);\n    }\n    \n    /**\n     * 构造函数\n     * @param errorCode 错误代码\n     * @param errorParams 错误参数\n     */\n    public BusinessException(String errorCode, Object[] errorParams) {\n        this.errorCode = errorCode;\n        this.errorParams = errorParams;\n    }\n    \n    // getter/setter方法\n}\n```\n\n## 5. 异常信息国际化\n\n为了支持多语言环境，可以实现异常信息的国际化：\n\n```java\n/**\n * 获取国际化的异常消息\n * @param exception 业务异常\n * @return 国际化后的消息\n */\nprivate String getLocalizedMessage(BusinessException exception) {\n    if (exception.getErrorCode() != null) {\n        // 使用消息资源获取国际化消息\n        return MessageResource.getMessage(\n            exception.getErrorCode(),\n            exception.getErrorParams()\n        );\n    } else {\n        // 使用异常原始消息\n        return exception.getMessage();\n    }\n}\n```\n\n## 6. 事务嵌套处理\n\n对于复杂业务场景，可能需要处理事务嵌套：\n\n```java\n/**\n * 在现有事务中执行操作\n * @param document 业务单据\n * @throws Throwable 处理异常\n */\nprivate void executeInExistingTransaction(Document document) throws Throwable {\n    // 检查是否已在事务中\n    boolean inTransaction = getMidContext().isInTransaction();\n    \n    if (inTransaction) {\n        // 已在事务中，直接执行操作\n        processInTransaction(document);\n    } else {\n        // 不在事务中，创建新事务\n        executeInTransaction(document);\n    }\n}\n```\n\n## 7. 事务隔离级别\n\n在某些特殊场景下，可能需要指定事务隔离级别：\n\n```java\n/**\n * 使用特定隔离级别执行事务\n * @param document 业务单据\n * @param isolationLevel 隔离级别\n * @return 处理结果ID\n * @throws Throwable 处理异常\n */\npublic Long executeWithIsolation(Document document, int isolationLevel) throws Throwable {\n    logger.info(\"开始执行特定隔离级别的事务操作\");\n    \n    // 获取上下文\n    IMidContext context = getMidContext();\n    \n    // 设置隔离级别并开始事务\n    // 注意：实际实现可能不同，这里仅为示例\n    // context.beginTransaction(isolationLevel);\n    \n    try {\n        // 执行业务操作\n        Long objectID = processInTransaction(document);\n        \n        // 提交事务\n        // context.commitTransaction();\n        \n        return objectID;\n    } catch (Throwable e) {\n        // 回滚事务\n        // context.rollbackTransaction();\n        throw e;\n    }\n}\n```\n\n## 8. 异常重试机制\n\n对于可能由于并发导致的临时性异常，可以实现重试机制：\n\n```java\n/**\n * 带重试机制的事务执行\n * @param document 业务单据\n * @return 处理结果ID\n * @throws Throwable 处理异常\n */\npublic Long executeWithRetry(Document document) throws Throwable {\n    final int MAX_RETRIES = 3;\n    final long RETRY_DELAY = 1000; // 毫秒\n    \n    int attempts = 0;\n    Throwable lastException = null;\n    \n    while (attempts < MAX_RETRIES) {\n        try {\n            attempts++;\n            return executeInTransaction(document);\n        } catch (ConcurrencyException e) {\n            // 只对并发异常进行重试\n            lastException = e;\n            logger.warn(\"执行遇到并发异常，准备第{}次重试: {}\", attempts, e.getMessage());\n            \n            // 延时后重试\n            if (attempts < MAX_RETRIES) {\n                Thread.sleep(RETRY_DELAY);\n            }\n        } catch (Throwable e) {\n            // 其他异常直接抛出，不重试\n            throw e;\n        }\n    }\n    \n    // 重试次数用尽，抛出最后一次异常\n    logger.error(\"重试{}次后仍然失败\", MAX_RETRIES);\n    throw lastException;\n}\n```\n\n通过以上方法和规范，Formula类可以有效地处理事务和异常，确保业务数据的一致性和系统的稳定性。这种实现方式符合ERP系统的业务需求，能够支持各种复杂的业务场景，包括本地事务、分布式事务和补偿事务等。"
      },
      {
        "role": "user",
        "content": "Formula类如何与其他模块进行交互和通信？"
      },
      {
        "role": "assistant",
        "content": "在ERP系统中，Formula类需要与其他模块进行交互和通信，以实现跨模块的业务流程。以下是Formula类与其他模块交互和通信的详细说明：\n\n## 1. 模块间交互的基本原则\n\n模块间交互应遵循以下基本原则：\n\n1. **松耦合**：模块之间应保持松散耦合，减少直接依赖\n2. **标准接口**：通过标准接口进行交互，而非直接调用实现类\n3. **数据封装**：交互数据应适当封装，避免暴露内部实现细节\n4. **异常处理**：妥善处理跨模块调用可能产生的异常\n5. **事务一致**：确保跨模块操作的事务一致性\n\n## 2. 直接调用其他模块的Formula类\n\n最简单的交互方式是直接调用其他模块的Formula类：\n\n```java\n/**\n * 调用其他模块的Formula类\n * @param document 业务单据\n * @throws Throwable 处理异常\n */\nprivate void callOtherModuleFormula(Document document) throws Throwable {\n    // 获取上下文\n    IMidContext context = getMidContext();\n    \n    // 创建其他模块的Formula实例\n    InventoryFormula inventoryFormula = new InventoryFormula(context);\n    \n    // 调用其方法\n    Long inventoryDocID = inventoryFormula.createInventoryDoc(\n        document.getWarehouseID(),\n        document.getOid(),\n        \"MM_PurchaseOrder\",  // 来源单据类型\n        document.getItems()   // 明细数据\n    );\n    \n    // 处理返回结果\n    if (inventoryDocID != null) {\n        // 更新关联信息\n        document.setInventoryDocID(inventoryDocID);\n        context.saveObject(document);\n        \n        logger.info(\"创建库存单据成功，ID: {}\", inventoryDocID);\n    }\n}\n```\n\n## 3. 使用服务接口进行交互\n\n更规范的方式是通过服务接口进行交互：\n\n```java\n/**\n * 通过服务接口调用其他模块\n * @param document 业务单据\n * @throws Throwable 处理异常\n */\nprivate void callOtherModuleService(Document document) throws Throwable {\n    // 获取服务接口\n    IInventoryService inventoryService = ServiceLocator.getService(IInventoryService.class);\n    \n    // 准备调用参数\n    InventoryDocumentDTO dto = new InventoryDocumentDTO();\n    dto.setWarehouseID(document.getWarehouseID());\n    dto.setSourceID(document.getOid());\n    dto.setSourceType(\"MM_PurchaseOrder\");\n    dto.setItems(convertToInventoryItems(document.getItems()));\n    \n    // 调用服务方法\n    InventoryResultDTO result = inventoryService.createInventoryDocument(dto);\n    \n    // 处理返回结果\n    if (result.isSuccess()) {\n        // 更新关联信息\n        document.setInventoryDocID(result.getDocumentID());\n        getMidContext().saveObject(document);\n        \n        logger.info(\"通过服务接口创建库存单据成功，ID: {}\", result.getDocumentID());\n    } else {\n        // 处理错误\n        throw new BusinessException(\"创建库存单据失败: \" + result.getErrorMessage());\n    }\n}\n\n/**\n * 转换为库存明细项\n * @param items 单据明细\n * @return 库存明细项列表\n */\nprivate List<InventoryItemDTO> convertToInventoryItems(List<DocumentItem> items) {\n\n\n```java\nprivate List<InventoryItemDTO> convertToInventoryItems(List<DocumentItem> items) {\n    List<InventoryItemDTO> inventoryItems = new ArrayList<>();\n    \n    for (DocumentItem item : items) {\n        InventoryItemDTO inventoryItem = new InventoryItemDTO();\n        inventoryItem.setMaterialID(item.getMaterialID());\n        inventoryItem.setQuantity(item.getQuantity());\n        inventoryItem.setUnitID(item.getUnitID());\n        // 设置其他属性...\n        \n        inventoryItems.add(inventoryItem);\n    }\n    \n    return inventoryItems;\n}\n```\n\n## 4. 使用事件机制进行通信\n\n对于松耦合的场景，可以使用事件机制进行通信：\n\n```java\n/**\n * 发布业务事件\n * @param document 业务单据\n * @throws Throwable 处理异常\n */\nprivate void publishBusinessEvent(Document document) throws Throwable {\n    // 创建事件对象\n    BusinessEvent event = new BusinessEvent();\n    event.setEventType(\"ORDER_APPROVED\");\n    event.setSourceModule(\"MM\");\n    event.setSourceType(\"PurchaseOrder\");\n    event.setSourceID(document.getOid());\n    event.setEventTime(new Date());\n    \n    // 设置事件数据\n    Map<String, Object> eventData = new HashMap<>();\n    eventData.put(\"documentNumber\", document.getDocumentNumber());\n    eventData.put(\"vendorID\", document.getVendorID());\n    eventData.put(\"totalAmount\", document.getTotalAmount());\n    // 设置其他需要的数据...\n    \n    event.setEventData(eventData);\n    \n    // 发布事件\n    EventPublisher publisher = EventPublisher.getInstance();\n    publisher.publishEvent(event);\n    \n    logger.info(\"发布业务事件: {}, 单据ID: {}\", event.getEventType(), document.getOid());\n}\n```\n\n## 5. 订阅和处理事件\n\n在Formula类中也可以订阅和处理其他模块发布的事件：\n\n```java\n/**\n * 事件处理类\n */\npublic class PurchaseOrderEventHandler implements EventHandler {\n    private static final Logger logger = LoggerFactory.getLogger(PurchaseOrderEventHandler.class);\n    \n    /**\n     * 处理事件\n     * @param event 业务事件\n     */\n    @Override\n    public void handleEvent(BusinessEvent event) {\n        try {\n            // 检查事件类型\n            if (\"INVENTORY_RECEIVED\".equals(event.getEventType())) {\n                // 处理库存接收事件\n                handleInventoryReceivedEvent(event);\n            } else if (\"PAYMENT_COMPLETED\".equals(event.getEventType())) {\n                // 处理付款完成事件\n                handlePaymentCompletedEvent(event);\n            }\n        } catch (Throwable e) {\n            logger.error(\"处理事件失败: {}\", e.getMessage(), e);\n        }\n    }\n    \n    /**\n     * 处理库存接收事件\n     * @param event 业务事件\n     * @throws Throwable 处理异常\n     */\n    private void handleInventoryReceivedEvent(BusinessEvent event) throws Throwable {\n        // 获取事件数据\n        Map<String, Object> eventData = event.getEventData();\n        Long sourceOrderID = (Long) eventData.get(\"sourceOrderID\");\n        String sourceType = (String) eventData.get(\"sourceType\");\n        \n        // 只处理与采购订单相关的事件\n        if (\"MM_PurchaseOrder\".equals(sourceType) && sourceOrderID != null) {\n            // 创建上下文\n            IMidContext context = ContextFactory.createContext();\n            \n            try {\n                // 创建Formula实例\n                PurchaseOrderFormula formula = new PurchaseOrderFormula(context);\n                \n                // 更新采购订单收货状态\n                formula.updateReceiptStatus(sourceOrderID);\n                \n                logger.info(\"处理库存接收事件完成，采购订单ID: {}\", sourceOrderID);\n            } finally {\n                // 释放上下文\n                if (context != null) {\n                    context.release();\n                }\n            }\n        }\n    }\n    \n    /**\n     * 处理付款完成事件\n     * @param event 业务事件\n     * @throws Throwable 处理异常\n     */\n    private void handlePaymentCompletedEvent(BusinessEvent event) throws Throwable {\n        // 实现类似的处理逻辑...\n    }\n}\n```\n\n## 6. 注册事件处理器\n\n事件处理器需要注册到事件系统：\n\n```java\n/**\n * 注册事件处理器\n */\npublic class MMEventHandlerRegistry implements IEventHandlerRegistry {\n    \n    /**\n     * 获取事件处理器列表\n     * @return 事件处理器数组\n     */\n    @Override\n    public EventHandler[] getEventHandlers() {\n        return new EventHandler[] {\n            new PurchaseOrderEventHandler(),\n            new MaterialEventHandler(),\n            // 其他事件处理器...\n        };\n    }\n}\n```\n\n## 7. 使用消息队列进行异步通信\n\n对于需要异步处理的场景，可以使用消息队列：\n\n```java\n/**\n * 发送异步消息\n * @param document 业务单据\n * @throws Throwable 处理异常\n */\nprivate void sendAsyncMessage(Document document) throws Throwable {\n    // 创建消息对象\n    BusinessMessage message = new BusinessMessage();\n    message.setMessageType(\"ORDER_CREATED\");\n    message.setSourceModule(\"MM\");\n    message.setSourceID(document.getOid());\n    message.setPriority(MessagePriority.NORMAL);\n    \n    // 设置消息内容\n    Map<String, Object> messageContent = new HashMap<>();\n    messageContent.put(\"documentNumber\", document.getDocumentNumber());\n    messageContent.put(\"documentDate\", document.getDocumentDate());\n    messageContent.put(\"totalAmount\", document.getTotalAmount());\n    // 设置其他需要的数据...\n    \n    message.setContent(messageContent);\n    \n    // 发送消息\n    MessageSender sender = MessageSender.getInstance();\n    sender.sendMessage(message);\n    \n    logger.info(\"发送异步消息: {}, 单据ID: {}\", message.getMessageType(), document.getOid());\n}\n```\n\n## 8. 处理异步消息\n\n在Formula类中也可以处理异步消息：\n\n```java\n/**\n * 消息处理类\n */\npublic class PurchaseOrderMessageHandler implements MessageHandler {\n    private static final Logger logger = LoggerFactory.getLogger(PurchaseOrderMessageHandler.class);\n    \n    /**\n     * 处理消息\n     * @param message 业务消息\n     * @return 处理结果\n     */\n    @Override\n    public boolean handleMessage(BusinessMessage message) {\n        try {\n            // 检查消息类型\n            if (\"INVENTORY_UPDATED\".equals(message.getMessageType())) {\n                // 处理库存更新消息\n                handleInventoryUpdatedMessage(message);\n                return true;\n            } else if (\"PRICE_CHANGED\".equals(message.getMessageType())) {\n                // 处理价格变更消息\n                handlePriceChangedMessage(message);\n                return true;\n            }\n            \n            // 不处理其他类型的消息\n            return false;\n        } catch (Throwable e) {\n            logger.error(\"处理消息失败: {}\", e.getMessage(), e);\n            return false;\n        }\n    }\n    \n    /**\n     * 处理库存更新消息\n     * @param message 业务消息\n     * @throws Throwable 处理异常\n     */\n    private void handleInventoryUpdatedMessage(BusinessMessage message) throws Throwable {\n        // 实现处理逻辑...\n    }\n    \n    /**\n     * 处理价格变更消息\n     * @param message 业务消息\n     * @throws Throwable 处理异常\n     */\n    private void handlePriceChangedMessage(BusinessMessage message) throws Throwable {\n        // 实现处理逻辑...\n    }\n}\n```\n\n## 9. 使用远程服务调用\n\n对于分布式部署的系统，可以使用远程服务调用：\n\n```java\n/**\n * 调用远程服务\n * @param document 业务单据\n * @throws Throwable 处理异常\n */\nprivate void callRemoteService(Document document) throws Throwable {\n    // 获取远程服务客户端\n    IRemoteServiceClient client = RemoteServiceClientFactory.createClient(\"FinanceService\");\n    \n    // 准备请求参数\n    Map<String, Object> parameters = new HashMap<>();\n    parameters.put(\"documentType\", \"PurchaseOrder\");\n    parameters.put(\"documentID\", document.getOid());\n    parameters.put(\"amount\", document.getTotalAmount());\n    parameters.put(\"currency\", document.getCurrency());\n    // 设置其他参数...\n    \n    // 调用远程服务\n    try {\n        Map<String, Object> result = client.invoke(\"createAccountingEntry\", parameters);\n        \n        // 处理返回结果\n        Boolean success = (Boolean) result.get(\"success\");\n        if (Boolean.TRUE.equals(success)) {\n            Long entryID = (Long) result.get(\"entryID\");\n            document.setAccountingEntryID(entryID);\n            getMidContext().saveObject(document);\n            \n            logger.info(\"调用远程服务创建会计分录成功，ID: {}\", entryID);\n        } else {\n            String errorMessage = (String) result.get(\"errorMessage\");\n            throw new BusinessException(\"创建会计分录失败: \" + errorMessage);\n        }\n    } catch (RemoteServiceException e) {\n        logger.error(\"调用远程服务失败: {}\", e.getMessage(), e);\n        throw new BusinessException(\"调用财务服务失败: \" + e.getMessage(), e);\n    }\n}\n```\n\n## 10. 使用数据集成接口\n\n对于需要数据集成的场景，可以使用专门的集成接口：\n\n```java\n/**\n * 通过数据集成接口与外部系统交互\n * @param document 业务单据\n * @throws Throwable 处理异常\n */\nprivate void integrateWithExternalSystem(Document document) throws Throwable {\n    // 获取集成接口\n    IDataIntegrationService integrationService = ServiceLocator.getService(IDataIntegrationService.class);\n    \n    // 准备集成数据\n    IntegrationData data = new IntegrationData();\n    data.setSourceSystem(\"ERP\");\n    data.setTargetSystem(\"CRM\");\n    data.setDataType(\"Order\");\n    data.setOperationType(\"Create\");\n    \n    // 设置业务数据\n    Map<String, Object> businessData = new HashMap<>();\n    businessData.put(\"orderNumber\", document.getDocumentNumber());\n    businessData.put(\"orderDate\", document.getDocumentDate());\n    businessData.put(\"customerID\", document.getBusinessPartnerID());\n    businessData.put(\"totalAmount\", document.getTotalAmount());\n    // 设置其他业务数据...\n    \n    data.setBusinessData(businessData);\n    \n    // 调用集成服务\n    IntegrationResult result = integrationService.sendData(data);\n    \n    // 处理返回结果\n    if (result.isSuccess()) {\n        // 更新集成状态\n        document.setIntegrationStatus(\"Integrated\");\n        document.setExternalSystemID(result.getExternalID());\n        getMidContext().saveObject(document);\n        \n        logger.info(\"数据集成成功，外部系统ID: {}\", result.getExternalID());\n    } else {\n        // 记录集成失败\n        document.setIntegrationStatus(\"Failed\");\n        document.setIntegrationError(result.getErrorMessage());\n        getMidContext().saveObject(document);\n        \n        logger.error(\"数据集成失败: {}\", result.getErrorMessage());\n        throw new BusinessException(\"与外部系统集成失败: \" + result.getErrorMessage());\n    }\n}\n```\n\n通过以上方法和规范，Formula类可以有效地与其他模块进行交互和通信，实现跨模块的业务流程。这种实现方式符合ERP系统的模块化设计原则，确保了系统的可扩展性和可维护性。"
      }
    ]
  }，=====================
  {
    "messages": [
    {
        "role": "user",
        "content": "我们的ERP系统需要开发一个销售订单管理功能，请问应该如何设计实体类和业务逻辑？"
    },
    {
        "role": "assistant",
        "content": "针对销售订单管理功能，我建议按以下方式设计：\n\n## 1. 实体类设计\n\n### 1.1 销售订单主表实体\n\n```java\npackage com.company.erp.sd.entity;\n\nimport java.math.BigDecimal;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * 销售订单实体类\n */\npublic class SalesOrder {\n    // 系统字段常量定义\n    public static final String FIELD_OID = \"OID\";\n    public static final String FIELD_SOID = \"SOID\";\n    public static final String FIELD_POID = \"POID\";\n    public static final String FIELD_STATUS = \"Status\";\n    \n    // 业务字段常量定义\n    public static final String FIELD_DOC_NUMBER = \"DocumentNumber\";\n    public static final String FIELD_CUSTOMER_ID = \"CustomerID\";\n    public static final String FIELD_ORDER_DATE = \"OrderDate\";\n    public static final String FIELD_DELIVERY_DATE = \"DeliveryDate\";\n    \n    // 系统字段\n    private Long oid;\n    private Long soid;\n    private Long poid;\n    private Integer status;\n    private Long creator;\n    private Date createTime;\n    private Long modifier;\n    private Date modifyTime;\n    \n    // 业务字段\n    private String documentNumber;\n    private Long customerID;\n    private String customerName;\n    private Date orderDate;\n    private Date deliveryDate;\n    private String currency;\n    private BigDecimal totalAmount;\n    private String remark;\n    \n    // 明细列表（不持久化，仅用于传输）\n    private List<SalesOrderItem> items;\n    \n    // getter/setter 方法略\n}\n```\n\n### 1.2 销售订单明细实体\n\n```java\npackage com.company.erp.sd.entity;\n\nimport java.math.BigDecimal;\nimport java.util.Date;\n\n/**\n * 销售订单明细实体类\n */\npublic class SalesOrderItem {\n    // 系统字段常量定义\n    public static final String FIELD_OID = \"OID\";\n    public static final String FIELD_SOID = \"SOID\";\n    \n    // 业务字段常量定义\n    public static final String FIELD_LINE_NUMBER = \"LineNumber\";\n    public static final String FIELD_MATERIAL_ID = \"MaterialID\";\n    public static final String FIELD_QUANTITY = \"Quantity\";\n    \n    // 系统字段\n    private Long oid;\n    private Long soid;  // 关联主表ID\n    \n    // 业务字段\n    private Integer lineNumber;\n    private Long materialID;\n    private String materialCode;\n    private String materialName;\n    private String unit;\n    private BigDecimal quantity;\n    private BigDecimal unitPrice;\n    private BigDecimal amount;\n    private Date deliveryDate;\n    private String remark;\n    \n    // getter/setter 方法略\n}\n```\n\n## 2. 业务逻辑处理类(Formula)\n\n```java\npackage com.company.erp.sd.formula;\n\nimport java.math.BigDecimal;\nimport java.util.Date;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.company.erp.function.EntityContextAction;\nimport com.company.erp.function.DocumentFunction;\nimport com.company.erp.sd.entity.SalesOrder;\n\n/**\n * 销售订单业务逻辑处理类\n */\npublic class SalesOrderFormula extends EntityContextAction {\n    private static final Logger logger = LoggerFactory.getLogger(SalesOrderFormula.class);\n    \n    // 状态常量定义\n    public static final int STATUS_DRAFT = 10;        // 草稿\n    public static final int STATUS_SUBMITTED = 20;    // 已提交\n    public static final int STATUS_APPROVED = 30;     // 已审批\n    public static final int STATUS_CLOSED = 40;       // 已关闭\n    public static final int STATUS_CANCELED = 90;     // 已取消\n    \n    /**\n     * 构造函数\n     */\n    public SalesOrderFormula(IMidContext context) throws Throwable {\n        super(context);\n    }\n    \n    /**\n     * 保存销售订单\n     */\n    public Long save(SalesOrder salesOrder) throws Throwable {\n        logger.info(\"开始保存销售订单\");\n        \n        // 验证必填字段\n        validateRequiredFields(salesOrder);\n        \n        // 生成单据编号\n        if (salesOrder.getDocumentNumber() == null) {\n            String docNumber = DocumentFunction.generateDocumentNumber(\n                getMidContext(),\n                \"SD\",     // 模块代码\n                \"SO\"      // 单据类型\n            );\n            salesOrder.setDocumentNumber(docNumber);\n        }\n        \n        // 保存主表数据\n        Long objectID = getMidContext().saveObject(salesOrder);\n        \n        // 保存明细数据\n        saveOrderItems(salesOrder);\n        \n        // 更新状态\n        updateOrderStatus(salesOrder, STATUS_DRAFT);\n        \n        logger.info(\"销售订单保存完成，ID: {}\", objectID);\n        return objectID;\n    }\n    \n    // 其他业务方法如提交、审核、取消等省略\n}\n```\n\n## 3. 注册器配置\n\n```java\npackage com.company.erp.sd.registry;\n\nimport com.company.erp.function.IExtendContextActionRegistry;\nimport com.company.erp.sd.formula.SalesOrderFormula;\n\npublic class SDContextActionRegistry implements IExtendContextActionRegistry {\n    @Override\n    public Class<?>[] getContextActions() {\n        return new Class<?>[] {\n            SalesOrderFormula.class,\n            // 其他SD模块Formula类\n        };\n    }\n}\n```\n\n## 4. DataObject XML定义\n\n```xml\n<DataObject Key=\"SD_SalesOrder\" Caption=\"销售订单\" PrimaryTableKey=\"ESD_SalesOrderHead\" PrimaryType=\"Entity\" Version=\"1\">\n    <TableCollection>\n        <!-- 销售订单主表 -->\n        <Table Key=\"ESD_SalesOrderHead\" Caption=\"销售订单头表\" IndexPrefix=\"ESD_SalesOrderHead\">\n            <!-- 系统字段 -->\n            <Column Key=\"OID\" Caption=\"对象标识\" DataType=\"Long\" />\n            <Column Key=\"Status\" Caption=\"状态\" DataType=\"Integer\" />\n            \n            <!-- 业务字段 -->\n            <Column Key=\"DocumentNumber\" Caption=\"订单编号\" DataType=\"Varchar\" Length=\"20\" />\n            <Column Key=\"CustomerID\" Caption=\"客户ID\" DataType=\"Long\" />\n            <Column Key=\"CustomerName\" Caption=\"客户名称\" DataType=\"Varchar\" Length=\"100\" />\n            <Column Key=\"OrderDate\" Caption=\"订单日期\" DataType=\"DateTime\" />\n            <Column Key=\"DeliveryDate\" Caption=\"交货日期\" DataType=\"DateTime\" />\n            <Column Key=\"TotalAmount\" Caption=\"总金额\" DataType=\"Numeric\" Precision=\"16\" Scale=\"2\" />\n        </Table>\n        \n        <!-- 销售订单明细表 -->\n        <Table Key=\"ESD_SalesOrderItem\" TableMode=\"Detail\" Caption=\"销售订单明细\" IndexPrefix=\"ESD_SalesOrderItem\">\n            <!-- 系统字段 -->\n            <Column Key=\"OID\" Caption=\"对象标识\" DataType=\"Long\" />\n            <Column Key=\"SOID\" Caption=\"主对象标识\" DataType=\"Long\" />\n            \n            <!-- 业务字段 -->\n            <Column Key=\"LineNumber\" Caption=\"行号\" DataType=\"Integer\" />\n            <Column Key=\"MaterialID\" Caption=\"物料ID\" DataType=\"Long\" />\n            <Column Key=\"MaterialName\" Caption=\"物料名称\" DataType=\"Varchar\" Length=\"100\" />\n            <Column Key=\"Quantity\" Caption=\"数量\" DataType=\"Numeric\" Precision=\"16\" Scale=\"3\" />\n            <Column Key=\"UnitPrice\" Caption=\"单价\" DataType=\"Numeric\" Precision=\"16\" Scale=\"2\" />\n            <Column Key=\"Amount\" Caption=\"金额\" DataType=\"Numeric\" Precision=\"16\" Scale=\"2\" />\n        </Table>\n    </TableCollection>\n</DataObject>\n```\n\n以上设计符合ERP系统的分层架构和编码规范，包括实体类设计、业务逻辑处理和数据对象定义。销售订单功能应该放在SD(Sales & Distribution)模块中，遵循统一的命名和结构规范。"
    },
    {
        "role": "user",
        "content": "销售订单审批流程应该如何实现？需要考虑哪些因素？"
    },
    {
        "role": "assistant",
        "content": "销售订单审批流程的实现需要考虑多个关键因素，包括状态管理、权限控制、业务规则验证和后续处理等。以下是完整的实现方案：\n\n## 1. 审批流程设计\n\n### 1.1 审批状态定义\n\n```java\n// 在SalesOrderFormula中定义状态常量\npublic static final int STATUS_DRAFT = 10;        // 草稿\npublic static final int STATUS_SUBMITTED = 20;    // 已提交\npublic static final int STATUS_APPROVING = 25;    // 审批中\npublic static final int STATUS_APPROVED = 30;     // 已审批\npublic static final int STATUS_REJECTED = 35;     // 已拒绝\npublic static final int STATUS_CLOSED = 40;       // 已关闭\npublic static final int STATUS_CANCELED = 90;     // 已取消\n```\n\n### 1.2 审批业务参数\n\n需要考虑以下业务参数：\n- 审批级别配置：根据金额、客户等级等确定需要几级审批\n- 审批人配置：每个级别对应的审批人或角色\n- 审批规则：如超过金额阈值需要更高级别审批\n\n## 2. 审批方法实现\n\n```java\n/**\n * 提交销售订单到审批流程\n * @param orderID 订单ID\n * @return 处理结果\n * @throws Throwable 处理异常\n */\npublic boolean submit(Long orderID) throws Throwable {\n    logger.info(\"开始提交销售订单审批，ID: {}\", orderID);\n    \n    // 1. 获取销售订单\n    SalesOrder order = getOrder(orderID);\n    \n    // 2. 验证当前状态\n    if (order.getStatus() != STATUS_DRAFT) {\n        throw new Throwable(\"只有草稿状态的销售订单可以提交审批\");\n    }\n    \n    // 3. 执行业务验证\n    validateOrderForSubmit(order);\n    \n    // 4. 确定审批路径和审批人\n    ApprovalPath approvalPath = determineApprovalPath(order);\n    \n    // 5. 启动工作流\n    String processInstanceId = startApprovalWorkflow(order, approvalPath);\n    \n    // 6. 更新订单状态和工作流信息\n    order.setStatus(STATUS_SUBMITTED);\n    order.setProcessInstanceId(processInstanceId);\n    order.setSubmitTime(new Date());\n    order.setSubmitter(getCurrentUserID());\n    getMidContext().saveObject(order);\n    \n    // 7. 记录审批历史\n    saveApprovalHistory(order, \"提交审批\", \"提交销售订单到审批流程\");\n    \n    logger.info(\"销售订单提交审批完成，ID: {}, 流程实例: {}\", orderID, processInstanceId);\n    return true;\n}\n\n/**\n * 审批销售订单\n * @param orderID 订单ID\n * @param approved 是否批准\n * @param approveComment 审批意见\n * @return 处理结果\n * @throws Throwable 处理异常\n */\npublic boolean approve(Long orderID, boolean approved, String approveComment) throws Throwable {\n    logger.info(\"开始处理销售订单审批，ID: {}, 审批结果: {}\", orderID, approved);\n    \n    // 1. 获取销售订单\n    SalesOrder order = getOrder(orderID);\n    \n    // 2. 验证当前状态\n    if (order.getStatus() != STATUS_SUBMITTED && order.getStatus() != STATUS_APPROVING) {\n        throw new Throwable(\"只有已提交或审批中状态的销售订单可以审批\");\n    }\n    \n    // 3. 验证审批权限\n    validateApprovalPermission(order);\n    \n    // 4. 获取当前审批任务\n    ApprovalTask currentTask = getApprovalTask(order.getProcessInstanceId());\n    if (currentTask == null) {\n        throw new Throwable(\"未找到当前审批任务\");\n    }\n    \n    // 5. 完成当前审批任务\n    completeApprovalTask(currentTask.getTaskId(), approved, approveComment);\n    \n    // 6. 检查审批流程状态\n    ApprovalProcessStatus processStatus = getApprovalProcessStatus(order.getProcessInstanceId());\n    \n    // 7. 更新订单状态\n    if (processStatus.isCompleted()) {\n        if (processStatus.isApproved()) {\n            // 审批通过，更新状态\n            order.setStatus(STATUS_APPROVED);\n            order.setApproveTime(new Date());\n            order.setApprover(getCurrentUserID());\n            \n            // 执行审批后处理\n            processAfterApprove(order);\n        } else {\n            // 审批拒绝，更新状态\n            order.setStatus(STATUS_REJECTED);\n            order.setRejectReason(approveComment);\n        }\n    } else {\n        // 流程未结束，更新到审批中状态\n        order.setStatus(STATUS_APPROVING);\n        \n        // 通知下一级审批人\n        notifyNextApprover(processStatus.getNextApprovers(), order);\n    }\n    \n    // 8. 保存订单状态\n    getMidContext().saveObject(order);\n    \n    // 9. 记录审批历史\n    String action = approved ? \"审批通过\" : \"审批拒绝\";\n    saveApprovalHistory(order, action, approveComment);\n    \n    logger.info(\"销售订单审批处理完成，ID: {}, 当前状态: {}\", orderID, order.getStatus());\n    return true;\n}\n```\n\n## 3. 审批流程相关功能实现\n\n### 3.1 确定审批路径\n\n```java\n/**\n * 确定审批路径\n * @param order 销售订单\n * @return 审批路径配置\n * @throws Throwable 处理异常\n */\nprivate ApprovalPath determineApprovalPath(SalesOrder order) throws Throwable {\n    // 创建审批路径对象\n    ApprovalPath path = new ApprovalPath();\n    path.setDocumentId(order.getOid());\n    path.setDocumentType(\"SD_SalesOrder\");\n    \n    // 获取审批配置\n    ApprovalConfig config = getApprovalConfig(\"SD_SalesOrder\");\n    \n    // 审批路径确定逻辑\n    BigDecimal orderAmount = order.getTotalAmount();\n    \n    // 根据金额确定审批级别\n    if (orderAmount.compareTo(config.getLevel1Amount()) <= 0) {\n        // 低金额，只需要一级审批\n        path.addApprover(1, getRoleUsers(\"SALES_MANAGER\"));\n    } else if (orderAmount.compareTo(config.getLevel2Amount()) <= 0) {\n        // 中等金额，需要二级审批\n        path.addApprover(1, getRoleUsers(\"SALES_MANAGER\"));\n        path.addApprover(2, getRoleUsers(\"FINANCE_MANAGER\"));\n    } else {\n        // 高金额，需要三级审批\n        path.addApprover(1, getRoleUsers(\"SALES_MANAGER\"));\n        path.addApprover(2, getRoleUsers(\"FINANCE_MANAGER\"));\n        path.addApprover(3, getRoleUsers(\"GENERAL_MANAGER\"));\n    }\n    \n    // 特殊客户处理\n    Customer customer = getCustomer(order.getCustomerID());\n    if (customer != null && customer.isVip()) {\n        // VIP客户订单需要添加客户经理审批\n        path.addApprover(1, Arrays.asList(customer.getManagerID()));\n    }\n    \n    // 信用检查\n    if (customer != null && !isCustomerCreditValid(customer, order.getTotalAmount())) {\n        // 信用额度不足，需要财务总监审批\n        path.addApprover(path.getLevels() + 1, getRoleUsers(\"FINANCE_DIRECTOR\"));\n    }\n    \n    return path;\n}\n```\n\n### 3.2 启动工作流\n\n```java\n/**\n * 启动审批工作流\n * @param order 销售订单\n * @param approvalPath 审批路径\n * @return 工作流实例ID\n * @throws Throwable 处理异常\n */\nprivate String startApprovalWorkflow(SalesOrder order, ApprovalPath approvalPath) throws Throwable {\n    // 获取工作流服务\n    WorkflowService workflowService = getWorkflowService();\n    \n    // 准备工作流参数\n    Map<String, Object> parameters = new HashMap<>();\n    parameters.put(\"documentId\", order.getOid());\n    parameters.put(\"documentNumber\", order.getDocumentNumber());\n    parameters.put(\"documentType\", \"SD_SalesOrder\");\n    parameters.put(\"totalAmount\", order.getTotalAmount());\n    parameters.put(\"currency\", order.getCurrency());\n    parameters.put(\"customerId\", order.getCustomerID());\n    parameters.put(\"customerName\", order.getCustomerName());\n    parameters.put(\"submitterId\", getCurrentUserID());\n    parameters.put(\"approvalPath\", approvalPath);\n    \n    // 启动工作流\n    String processInstanceId = workflowService.startProcess(\n        \"salesOrderApproval\",  // 流程定义ID\n        \"SO-\" + order.getOid(),  // 业务键\n        parameters              // 流程参数\n    );\n    \n    return processInstanceId;\n}\n```\n\n### 3.3 审批权限验证\n\n```java\n/**\n * 验证审批权限\n * @param order 销售订单\n * @throws Throwable 验证失败抛出异常\n */\nprivate void validateApprovalPermission(SalesOrder order) throws Throwable {\n    // 获取当前用户ID\n    Long currentUserId = getCurrentUserID();\n    \n    // 获取当前审批任务\n    ApprovalTask currentTask = getApprovalTask(order.getProcessInstanceId());\n    if (currentTask == null) {\n        throw new Throwable(\"未找到当前审批任务\");\n    }\n    \n    // 检查当前用户是否为审批人\n    if (!currentTask.getAssignee().equals(currentUserId.toString()) && \n        !currentTask.getCandidateUsers().contains(currentUserId.toString())) {\n        \n        // 检查用户角色\n        boolean hasRole = false;\n        List<String> userRoles = getUserRoles(currentUserId);\n        for (String role : currentTask.getCandidateGroups()) {\n            if (userRoles.contains(role)) {\n                hasRole = true;\n                break;\n            }\n        }\n        \n        if (!hasRole) {\n            throw new Throwable(\"当前用户没有审批权限\");\n        }\n    }\n}\n```\n\n## 4. 审批后业务处理\n\n```java\n/**\n * 审批通过后的业务处理\n * @param order 销售订单\n * @throws Throwable 处理异常\n */\nprivate void processAfterApprove(SalesOrder order) throws Throwable {\n    // 1. 锁定库存\n    reserveInventory(order);\n    \n    // 2. 生成出库单\n    generateDeliveryOrder(order);\n    \n    // 3. 更新客户信用额度使用情况\n    updateCustomerCreditUsage(order.getCustomerID(), order.getTotalAmount());\n    \n    // 4. 更新销售统计数据\n    updateSalesStatistics(order);\n    \n    // 5. 发送通知\n    sendApprovalNotification(order, \"销售订单已审批通过\");\n    \n    // 6. 创建后续任务\n    createFollowUpTasks(order);\n}\n```\n\n## 5. 审批历史记录\n\n```java\n/**\n * 保存审批历史记录\n * @param order 销售订单\n * @param action 审批动作\n * @param comment 审批意见\n * @throws Throwable 处理异常\n */\nprivate void saveApprovalHistory(SalesOrder order, String action, String comment) throws Throwable {\n    // 创建审批历史记录对象\n    ApprovalHistory history = new ApprovalHistory();\n    history.setDocumentId(order.getOid());\n    history.setDocumentType(\"SD_SalesOrder\");\n    history.setDocumentNumber(order.getDocumentNumber());\n    history.setAction(action);\n    history.setComment(comment);\n    history.setApprover(getCurrentUserID());\n    history.setApproverName(getCurrentUserName());\n    history.setApproveTime(new Date());\n    history.setStatus(order.getStatus());\n    \n    // 保存历史记录\n    getMidContext().saveObject(history);\n}\n```\n\n## 6. 需要考虑的关键因素\n\n1. **多级审批控制**：\n   - 根据金额、客户等级自动确定审批级别\n   - 支持串行和并行审批流程\n   - 允许跳过特定级别审批（特定条件下）\n\n2. **权限管理**：\n   - 严格控制审批权限，确保合规性\n   - a审核人与提交人不能是同一人\n   - 支持角色和具体用户设置审批权限\n\n3. **业务规则验证**：\n   - 客户信用额度检查\n   - 库存可用性检查\n   - 价格政策合规性检查\n   - 特殊客户或产品的特殊审批规则\n\n4. **异常处理**：\n   - 审批超时处理机制\n   - 审批人缺席时的代理审批机制\n   - 审批环节出错时的回滚或补偿机制\n\n5. **集成考虑**：\n   - 与工作流引擎的集成\n   - 与通知系统集成（邮件、短信、内部消息）\n   - 与库存模块、财务模块的集成\n\n6. **审计和合规**：\n   - 完整的审批历史记录\n   - 防篡改的审批日志\n   - 支持合规性报告生成\n\n7. **用户体验**：\n   - 支持移动端审批\n   - 批量审批功能\n   - 审批提醒和到期警告\n\n以上实现方案和考虑因素涵盖了销售订单审批流程的主要方面，确保审批流程的规范性、灵活性和安全性。"
    },
    {
        "role": "user",
        "content": "库存管理模块与销售模块如何集成？在处理销售订单时如何检查和锁定库存？"
    },
    {
        "role": "assistant",
        "content": "# 库存管理模块与销售模块的集成方案\n\n库存管理模块(WM, Warehouse Management)与销售模块(SD, Sales & Distribution)的集成是ERP系统中的关键环节，尤其是在处理销售订单时的库存检查和锁定机制。以下是详细的集成方案：\n\n## 1. 模块间集成架构\n\n### 1.1 集成原则\n\n- **松耦合设计**：通过标准接口通信，降低直接依赖性\n- **事务一致性**：确保跨模块操作的数据一致性\n- **实时同步**：库存变动需要实时反映到销售订单状态\n- **可追溯性**：记录库存操作与销售订单的关联关系\n\n### 1.2 集成方式\n\n```java\n// 库存服务接口定义 - 放在公共模块中\npackage com.company.erp.wm.service;\n\nimport java.math.BigDecimal;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * 库存服务接口\n */\npublic interface IInventoryService {\n    /**\n     * 检查库存可用性\n     * @param warehouseID 仓库ID\n     * @param materialID 物料ID\n     * @param quantity 需求数量\n     * @return 是否可用\n     */\n    boolean checkInventoryAvailability(Long warehouseID, Long materialID, BigDecimal quantity);\n    \n    /**\n     * 批量检查多个物料的库存可用性\n     * @param warehouseID 仓库ID\n     * @param materialQuantities 物料ID和数量的映射\n     * @return 每个物料的可用性结果\n     */\n    Map<Long, Boolean> batchCheckInventoryAvailability(Long warehouseID, Map<Long, BigDecimal> materialQuantities);\n    \n    /**\n     * 锁定库存\n     * @param sourceDocID 来源单据ID\n     * @param sourceDocType 来源单据类型\n     * @param warehouseID 仓库ID\n     * @param materialID 物料ID\n     * @param quantity 锁定数量\n     * @return 锁定记录ID\n     */\n    Long lockInventory(Long sourceDocID, String sourceDocType, Long warehouseID, Long materialID, BigDecimal quantity);\n    \n    /**\n     * 批量锁定库存\n     * @param sourceDocID 来源单据ID\n     * @param sourceDocType 来源单据类型\n     * @param warehouseID 仓库ID\n     * @param materialQuantities 物料ID和数量的映射\n     * @return 锁定记录ID列表\n     */\n    List<Long> batchLockInventory(Long sourceDocID, String sourceDocType, Long warehouseID, Map<Long, BigDecimal> materialQuantities);\n    \n    /**\n     * 解锁库存\n     * @param lockID 锁定记录ID\n     * @return 是否成功\n     */\n    boolean unlockInventory(Long lockID);\n    \n    /**\n     * 根据来源单据解锁库存\n     * @param sourceDocID 来源单据ID\n     * @param sourceDocType 来源单据类型\n     * @return 解锁的记录数\n     */\n    int unlockInventoryBySource(Long sourceDocID, String sourceDocType);\n    \n    /**\n     * 获取物料当前库存\n     * @param warehouseID 仓库ID\n     * @param materialID 物料ID\n     * @return 库存数量信息\n     */\n    InventoryLevel getInventoryLevel(Long warehouseID, Long materialID);\n}\n```\n\n## 2. 销售订单中的库存检查实现\n\n在销售订单保存或提交阶段，需要检查库存可用性：\n\n```java\n/**\n * 检查销售订单库存可用性\n * @param order 销售订单\n * @return 库存检查结果\n * @throws Throwable 处理异常\n */\nprivate InventoryCheckResult checkOrderInventory(SalesOrder order) throws Throwable {\n    logger.info(\"开始检查销售订单库存，订单号: {}\", order.getDocumentNumber());\n    \n    // 获取库存服务\n    IInventoryService inventoryService = ServiceLocator.getService(IInventoryService.class);\n    \n    // 准备检查参数\n    Long warehouseID = order.getWarehouseID(); // 假设订单头有指定仓库\n    Map<Long, BigDecimal> materialQuantities = new HashMap<>();\n    Map<Long, SalesOrderItem> materialItemMap = new HashMap<>();\n    \n    // 收集所有物料和数量\n    for (SalesOrderItem item : order.getItems()) {\n        // 对每个物料累加数量(可能有多行同一物料)\n        materialQuantities.merge(\n            item.getMaterialID(), \n            item.getQuantity(), \n            BigDecimal::add\n        );\n        materialItemMap.put(item.getMaterialID(), item); // 记录每个物料对应的订单行\n    }\n    \n    // 批量检查库存可用性\n    Map<Long, Boolean> availabilityResults = \n        inventoryService.batchCheckInventoryAvailability(warehouseID, materialQuantities);\n    \n    // 处理检查结果\n    InventoryCheckResult result = new InventoryCheckResult();\n    result.setAllAvailable(true); // 假设初始全部可用\n    \n    for (Map.Entry<Long, Boolean> entry : availabilityResults.entrySet()) {\n        Long materialID = entry.getKey();\n        Boolean isAvailable = entry.getValue();\n        \n        if (!isAvailable) {\n            // 添加库存不足的物料信息\n            SalesOrderItem item = materialItemMap.get(materialID);\n            result.addUnavailableItem(\n                materialID,\n                item.getMaterialCode(),\n                item.getMaterialName(),\n                materialQuantities.get(materialID),\n                inventoryService.getInventoryLevel(warehouseID, materialID).getAvailableQuantity()\n            );\n            result.setAllAvailable(false);\n        }\n    }\n    \n    logger.info(\"销售订单库存检查完成，全部可用: {}\", result.isAllAvailable());\n    return result;\n}\n```\n\n## 3. 销售订单审批通过后的库存锁定\n\n在销售订单审批通过后，需要锁定库存以防止超卖：\n\n```java\n/**\n * 锁定销售订单库存\n * @param order 销售订单\n * @return 锁定结果\n * @throws Throwable 处理异常\n */\nprivate InventoryLockResult lockOrderInventory(SalesOrder order) throws Throwable {\n    logger.info(\"开始锁定销售订单库存，订单号: {}\", order.getDocumentNumber());\n    \n    // 先检查库存可用性\n    InventoryCheckResult checkResult = checkOrderInventory(order);\n    if (!checkResult.isAllAvailable()) {\n        // 如果库存不足，返回错误\n        throw new BusinessException(\"库存不足，无法锁定\", checkResult.getUnavailableItems());\n    }\n    \n    // 获取库存服务\n    IInventoryService inventoryService = ServiceLocator.getService(IInventoryService.class);\n    \n    // 准备锁定参数\n    Long warehouseID = order.getWarehouseID();\n    Map<Long, BigDecimal> materialQuantities = new HashMap<>();\n    \n    // 汇总物料数量\n    for (SalesOrderItem item : order.getItems()) {\n        materialQuantities.merge(item.getMaterialID(), item.getQuantity(), BigDecimal::add);\n    }\n    \n    // 批量锁定库存\n    List<Long> lockIDs = inventoryService.batchLockInventory(\n        order.getOid(),          // 来源单据ID\n        \"SD_SalesOrder\",        // 来源单据类型\n        warehouseID,             // 仓库ID\n        materialQuantities       // 物料数量映射\n    );\n    \n    // 记录锁定信息到订单\n    order.setInventoryLocked(true);\n    order.setInventoryLockTime(new Date());\n    order.setInventoryLockIDs(String.join(\",\", lockIDs.stream().map(String::valueOf).collect(Collectors.toList())));\n    getMidContext().saveObject(order);\n    \n    // 记录库存操作日志\n    saveInventoryOperationLog(order, \"锁定\", lockIDs);\n    \n    // 创建返回结果\n    InventoryLockResult result = new InventoryLockResult();\n    result.setSuccess(true);\n    result.setLockIDs(lockIDs);\n    result.setLockTime(new Date());\n    \n    logger.info(\"销售订单库存锁定完成，订单号: {}, 锁定记录数: {}\", order.getDocumentNumber(), lockIDs.size());\n    return result;\n}\n```\n\n## 4. 库存解锁实现\n\n在订单取消或变更时，需要解锁库存：\n\n```java\n/**\n * 解锁销售订单库存\n * @param order 销售订单\n * @return 解锁结果\n * @throws Throwable 处理异常\n */\nprivate InventoryUnlockResult unlockOrderInventory(SalesOrder order) throws Throwable {\n    logger.info(\"开始解锁销售订单库存，订单号: {}\", order.getDocumentNumber());\n    \n    // 检查是否已锁定库存\n    if (!order.isInventoryLocked()) {\n        logger.info(\"销售订单未锁定库存，无需解锁，订单号: {}\", order.getDocumentNumber());\n        return new InventoryUnlockResult(true, 0);\n    }\n    \n    // 获取库存服务\n    IInventoryService inventoryService = ServiceLocator.getService(IInventoryService.class);\n    \n    // 解锁库存\n    int count = inventoryService.unlockInventoryBySource(order.getOid(), \"SD_SalesOrder\");\n    \n    // 更新订单信息\n    order.setInventoryLocked(false);\n    order.setInventoryUnlockTime(new Date());\n    getMidContext().saveObject(order);\n    \n    // 记录库存操作日志\n    saveInventoryOperationLog(order, \"解锁\", null);\n    \n    // 创建返回结果\n    InventoryUnlockResult result = new InventoryUnlockResult(true, count);\n    \n    logger.info(\"销售订单库存解锁完成，订单号: {}, 解锁记录数: {}\", order.getDocumentNumber(), count);\n    return result;\n}\n```\n\n## 5. 库存事件处理\n\n通过事件机制处理库存相关通知：\n\n```java\n/**\n * 库存变动事件处理类\n */\npublic class SalesOrderInventoryEventHandler implements EventHandler {\n    private static final Logger logger = LoggerFactory.getLogger(SalesOrderInventoryEventHandler.class);\n    \n    /**\n     * 处理事件\n     * @param event 业务事件\n     */\n    @Override\n    public void handleEvent(BusinessEvent event) {\n        try {\n            if (\"INVENTORY_CHANGED\".equals(event.getEventType())) {\n                handleInventoryChangedEvent(event);\n            } else if (\"INVENTORY_SHORTAGE\".equals(event.getEventType())) {\n                handleInventoryShortageEvent(event);\n            }\n        } catch (Throwable e) {\n            logger.error(\"处理库存事件失败: {}\", e.getMessage(), e);\n        }\n    }\n    \n    /**\n     * 处理库存变动事件\n     * @param event 业务事件\n     */\n    private void handleInventoryChangedEvent(BusinessEvent event) throws Throwable {\n        Map<String, Object> eventData = event.getEventData();\n        Long materialID = (Long) eventData.get(\"materialID\");\n        Long warehouseID = (Long) eventData.get(\"warehouseID\");\n        \n        // 查找受影响的销售订单\n        List<SalesOrder> affectedOrders = findAffectedSalesOrders(materialID, warehouseID);\n        \n        for (SalesOrder order : affectedOrders) {\n            // 更新订单库存状态\n            updateOrderInventoryStatus(order);\n            \n            // 通知相关人员\n            notifyInventoryChange(order, materialID);\n        }\n    }\n    \n    /**\n     * 处理库存短缺事件\n     * @param event 业务事件\n     */\n    private void handleInventoryShortageEvent(BusinessEvent event) throws Throwable {\n        // 处理库存短缺逻辑...\n    }\n}\n```\n\n## 6. 集成实现的关键点\n\n### 6.1 库存检查策略\n\n可以根据业务需求实现不同的库存检查策略：\n\n```java\npublic enum InventoryCheckStrategy {\n    CHECK_AVAILABLE,      // 检查可用库存（实际库存 - 已分配库存）\n    CHECK_PHYSICAL,       // 检查实际库存（不考虑已分配）\n    CHECK_ATP,            // 检查ATP（可供销售量）\n    CHECK_WITH_FORECAST   // 结合预测数据检查\n}\n```\n\n### 6.2 库存锁定级别\n\n不同的业务流程可能需要不同的锁定级别：\n\n```java\npublic enum InventoryLockLevel {\n    SOFT_ALLOCATION,      // 软分配（可以被优先级更高的订单抢占）\n    HARD_ALLOCATION,      // 硬分配（不可抢占）\n    PHYSICAL_ALLOCATION   // 物理分配（关联到具体库位/批次）\n}\n```\n\n### 6.3 批次和序列号处理\n\n对于需要批次控制或序列号管理的物料，需要特殊处理：\n\n```java\n/**\n * 锁定批次库存\n * @param order 销售订单\n * @return 锁定结果\n */\nprivate InventoryLockResult lockBatchInventory(SalesOrder order) throws Throwable {\n    // 批次管理物料的特殊处理...\n    // 可能需要用户指定具体批次或系统按FIFO/FEFO策略选择批次\n    \n    // 查询符合条件的批次\n    List<InventoryBatch> availableBatches = inventoryService.findAvailableBatches(\n        order.getWarehouseID(),\n        materialID,\n        quantity,\n        new BatchSelectionCriteria(\"FEFO\")  // 按到期日优先(First Expired First Out)\n    );\n    \n    // 锁定库存批次\n    // ...\n}\n```\n\n## 7. 库存与销售集成的最佳实践\n\n1. **避免硬编码依赖**：使用服务接口和事件机制实现模块间通信\n\n2. **处理并发控制**：利用乐观锁或悲观锁确保库存数据一致性\n\n3. **实现补偿机制**：处理库存锁定失败的回滚和补偿策略\n\n4. **缓存库存信息**：在销售模块适当缓存关键库存数据，减少频繁跨模块查询\n\n5. **分级库存缺货处理**：\n   - 完全不足：拒绝处理订单或转为缺货处理\n   - 部分不足：支持部分发货或等待补货\n   - 期望日期内不足：提供替代品或延期交货\n\n6. **配置驱动集成**：通过配置控制不同业务场景下的集成行为，而非硬编码\n\n7. **全程可追溯**：记录详细的库存操作日志，关联销售订单和库存变动\n\n通过以上设计和实现，可以确保销售模块和库存管理模块之间的有效集成，提供准确、实时的库存检查和锁定功能，支持完整的销售订单处理流程。"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "如何设计ERP系统的用户权限管理功能？"
      },
      {
        "role": "assistant",
        "content": "# ERP系统用户权限管理功能设计方案\n\n用户权限管理是ERP系统的核心基础功能，需要全面而精细的设计。以下是完整的设计方案：\n\n## 1. 权限模型设计\n\n### 1.1 多层次权限模型\n\n采用RBAC (Role-Based Access Control) 与ABAC (Attribute-Based Access Control) 相结合的权限模型：\n\n```java\npackage com.company.erp.auth.entity;\n\n/**\n * 用户实体\n */\npublic class User {\n    private Long id;\n    private String username;\n    private String password; // 加密存储\n    private String realName;\n    private String email;\n    private String mobile;\n    private Boolean enabled;\n    private Date lastLoginTime;\n    private Integer loginFailCount;\n    \n    // 用户所属组织机构\n    private Long organizationID;\n    // 用户所属部门\n    private Long departmentID;\n    // 用户职位\n    private Long positionID;\n    \n    // 其他用户属性...\n}\n\n/**\n * 角色实体\n */\npublic class Role {\n    private Long id;\n    private String code;        // 角色编码\n    private String name;        // 角色名称\n    private String description; // 角色描述\n    private Integer roleType;   // 角色类型：系统角色、业务角色等\n    private Boolean enabled;    // 是否启用\n}\n\n/**\n * 权限实体\n */\npublic class Permission {\n    private Long id;\n    private String code;        // 权限编码\n    private String name;        // 权限名称\n    private String description; // 权限描述\n    private String resourceType;// 资源类型：菜单、按钮、API、数据等\n    private String resourceCode;// 资源编码\n    private String actionType;  // 操作类型：查看、新增、修改、删除等\n}\n```\n\n### 1.2 关联关系定义\n\n```java\n/**\n * 用户-角色关联\n */\npublic class UserRole {\n    private Long id;\n    private Long userId;\n    private Long roleId;\n    private Date grantTime;     // 授权时间\n    private Long grantBy;       // 授权人\n    private Date expiryTime;    // 过期时间（可选）\n}\n\n/**\n * 角色-权限关联\n */\npublic class RolePermission {\n    private Long id;\n    private Long roleId;\n    private Long permissionId;\n    private Date grantTime;\n    private Long grantBy;\n}\n\n/**\n * 用户-权限直接关联（用于特殊授权）\n */\npublic class UserPermission {\n    private Long id;\n    private Long userId;\n    private Long permissionId;\n    private Date grantTime;\n    private Long grantBy;\n    private Date expiryTime;\n    private Boolean isDeny;      // 是否为拒绝权限\n}\n```\n\n## 2. 数据权限设计\n\n### 2.1 数据权限规则\n\n```java\n/**\n * 数据权限规则\n */\npublic class DataPermissionRule {\n    private Long id;\n    private String ruleCode;     // 规则编码\n    private String ruleName;     // 规则名称\n    private String objectType;   // 数据对象类型\n    private String filterType;   // 过滤类型：按组织、按部门、按区域等\n    private String filterExpression; // 过滤表达式\n    private Integer priority;    // 优先级\n}\n\n/**\n * 角色-数据权限规则关联\n */\npublic class RoleDataPermission {\n    private Long id;\n    private Long roleId;\n    private Long dataPermissionRuleId;\n}\n\n/**\n * 用户-数据权限规则关联\n */\npublic class UserDataPermission {\n    private Long id;\n    private Long userId;\n    private Long dataPermissionRuleId;\n}\n```\n\n## 3. 功能模块设计\n\n### 3.1 用户认证模块\n\n```java\npackage com.company.erp.auth.service;\n\n/**\n * 认证服务接口\n */\npublic interface IAuthenticationService {\n    /**\n     * 用户登录\n     */\n    LoginResult login(String username, String password, String captchaCode);\n    \n    /**\n     * 用户退出\n     */\n    void logout(String token);\n    \n    /**\n     * 检查用户登录状态\n     */\n    UserSession checkSession(String token);\n    \n    /**\n     * 刷新令牌\n     */\n    String refreshToken(String token);\n    \n    /**\n     * 更改密码\n     */\n    boolean changePassword(Long userId, String oldPassword, String newPassword);\n    \n    /**\n     * 重置密码\n     */\n    String resetPassword(Long userId);\n}\n```\n\n### 3.2 授权服务模块\n\n```java\n/**\n * 授权服务接口\n */\npublic interface IAuthorizationService {\n    /**\n     * 检查用户是否有指定权限\n     */\n    boolean hasPermission(Long userId, String permissionCode);\n    \n    /**\n     * 获取用户所有权限\n     */\n    List<Permission> getUserPermissions(Long userId);\n    \n    /**\n     * 获取用户所有角色\n     */\n    List<Role> getUserRoles(Long userId);\n    \n    /**\n     * 授予用户角色\n     */\n    void grantRoleToUser(Long userId, Long roleId, Long grantBy);\n    \n    /**\n     * 撤销用户角色\n     */\n    void revokeRoleFromUser(Long userId, Long roleId);\n    \n    /**\n     * 授予角色权限\n     */\n    void grantPermissionToRole(Long roleId, Long permissionId, Long grantBy);\n    \n    /**\n     * 撤销角色权限\n     */\n    void revokePermissionFromRole(Long roleId, Long permissionId);\n}\n```\n\n### 3.3 数据权限过滤服务\n\n```java\n/**\n * 数据权限过滤服务\n */\npublic interface IDataPermissionService {\n    /**\n     * 获取SQL过滤条件\n     */\n    String getSqlFilterCondition(Long userId, String objectType);\n    \n    /**\n     * 过滤数据列表（内存过滤）\n     */\n    <T> List<T> filterDataList(Long userId, String objectType, List<T> dataList);\n    \n    /**\n     * 检查数据访问权限\n     */\n    boolean checkDataAccess(Long userId, String objectType, Long dataId);\n    \n    /**\n     * 获取用户数据权限规则\n     */\n    List<DataPermissionRule> getUserDataPermissionRules(Long userId, String objectType);\n}\n```\n\n## 4. 权限验证实现\n\n### 4.1 注解式权限控制\n\n```java\n/**\n * 权限注解\n */\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RequiresPermission {\n    /**\n     * 权限编码\n     */\n    String value();\n    \n    /**\n     * 逻辑类型：AND, OR\n     */\n    LogicType logic() default LogicType.AND;\n    \n    /**\n     * 错误处理类型\n     */\n    ErrorType errorType() default ErrorType.EXCEPTION;\n}\n\n/**\n * 权限拦截器\n */\npublic class PermissionInterceptor implements MethodInterceptor {\n    @Autowired\n    private IAuthorizationService authorizationService;\n    \n    @Override\n    public Object invoke(MethodInvocation invocation) throws Throwable {\n        // 获取方法上的权限注解\n        RequiresPermission annotation = invocation.getMethod().getAnnotation(RequiresPermission.class);\n        if (annotation == null) {\n            // 从类上获取\n            annotation = invocation.getThis().getClass().getAnnotation(RequiresPermission.class);\n        }\n        \n        if (annotation != null) {\n            // 获取当前用户ID\n            Long userId = getCurrentUserId();\n            \n            // 验证权限\n            boolean hasPermission = authorizationService.hasPermission(userId, annotation.value());\n            \n            if (!hasPermission) {\n                if (annotation.errorType() == ErrorType.EXCEPTION) {\n                    throw new AuthorizationException(\"权限不足\");\n                } else {\n                    return null; // 或其他默认值\n                }\n            }\n        }\n        \n        return invocation.proceed();\n    }\n}\n```\n\n### 4.2 数据权限过滤实现\n\n```java\n/**\n * 数据权限过滤器\n */\npublic class DataPermissionFilter implements SqlSegmentInterceptor {\n    @Autowired\n    private IDataPermissionService dataPermissionService;\n    \n    @Override\n    public String processSql(String sql, String objectType) {\n        // 获取当前用户ID\n        Long userId = getCurrentUserId();\n        \n        // 获取数据权限过滤条件\n        String filterCondition = dataPermissionService.getSqlFilterCondition(userId, objectType);\n        \n        // 如果有过滤条件，添加到SQL中\n        if (StringUtils.isNotEmpty(filterCondition)) {\n            sql = addFilterConditionToSql(sql, filterCondition);\n        }\n        \n        return sql;\n    }\n    \n    private String addFilterConditionToSql(String sql, String filterCondition) {\n        // 处理SQL，添加过滤条件\n        // ...\n        return modifiedSql;\n    }\n}\n```\n\n## 5. 菜单和功能权限配置\n\n### 5.1 菜单定义\n\n```java\n/**\n * 菜单实体\n */\npublic class Menu {\n    private Long id;\n    private String code;        // 菜单编码\n    private String name;        // 菜单名称\n    private String url;         // 菜单URL\n    private String icon;        // 菜单图标\n    private Integer orderNum;   // 排序号\n    private Long parentId;      // 父菜单ID\n    private Integer level;      // 菜单级别\n    private String permissionCode; // 关联权限编码\n    private Boolean visible;    // 是否可见\n}\n\n/**\n * 功能按钮实体\n */\npublic class Button {\n    private Long id;\n    private String code;        // 按钮编码\n    private String name;        // 按钮名称\n    private String icon;        // 按钮图标\n    private Long menuId;        // 所属菜单ID\n    private String permissionCode; // 关联权限编码\n    private Boolean visible;    // 是否可见\n}\n```\n\n### 5.2 用户菜单服务\n\n```java\n/**\n * 用户菜单服务\n */\npublic interface IUserMenuService {\n    /**\n     * 获取用户菜单树\n     */\n    List<MenuNode> getUserMenuTree(Long userId);\n    \n    /**\n     * 获取用户菜单按钮权限\n     */\n    Map<String, List<String>> getUserMenuButtons(Long userId);\n    \n    /**\n     * 检查用户菜单访问权限\n     */\n    boolean checkMenuAccess(Long userId, String menuCode);\n}\n```\n\n## 6. 权限审计日志\n\n```java\n/**\n * 权限操作日志\n */\npublic class AuthOperationLog {\n    private Long id;\n    private String operationType;  // 操作类型\n    private Long operatorId;       // 操作人ID\n    private String operatorName;   // 操作人姓名\n    private Date operationTime;    // 操作时间\n    private String operationTarget; // 操作目标（用户/角色/权限）\n    private Long targetId;         // 目标ID\n    private String targetName;     // 目标名称\n    private String operationDetail; // 操作详情\n    private String clientIp;       // 客户端IP\n}\n\n/**\n * 权限审计服务\n */\npublic interface IAuthAuditService {\n    /**\n     * 记录权限操作日志\n     */\n    void logAuthOperation(AuthOperationLog log);\n    \n    /**\n     * 查询权限操作日志\n     */\n    Page<AuthOperationLog> queryAuthOperationLogs(AuthOperationLogQuery query, int pageNum, int pageSize);\n    \n    /**\n     * 导出权限操作日志\n     */\n    byte[] exportAuthOperationLogs(AuthOperationLogQuery query);\n}\n```\n\n## 7. 权限管理界面设计\n\n### 7.1 界面功能清单\n\n1. **用户管理**\n   - 用户列表/查询/筛选\n   - 创建/编辑/禁用用户\n   - 重置密码\n   - 用户角色分配\n   - 用户直接权限分配\n   - 用户数据权限配置\n   - 用户操作日志查看\n\n2. **角色管理**\n   - 角色列表/查询\n   - 创建/编辑/删除角色\n   - 角色权限分配\n   - 角色数据权限配置\n   - 角色用户查看\n   - 角色权限操作日志\n\n3. **权限管理**\n   - 权限列表/查询\n   - 权限分类管理\n   - 权限使用情况查看\n   - 权限测试工具\n\n4. **菜单管理**\n   - 菜单树结构维护\n   - 按钮权限配置\n   - 菜单权限关联\n\n5. **审计日志**\n   - 登录日志\n   - 操作日志\n   - 权限变更记录\n\n## 8. 权限初始化与升级\n\n```java\n/**\n * 权限初始化器\n */\npublic class PermissionInitializer implements ApplicationRunner {\n    @Autowired\n    private IPermissionService permissionService;\n    \n    @Autowired\n    private IRoleService roleService;\n    \n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        // 加载权限定义文件\n        List<PermissionDefinition> definitions = loadPermissionDefinitions();\n        \n        // 更新系统权限\n        permissionService.syncPermissions(definitions);\n        \n        // 初始化系统角色\n        initSystemRoles();\n    }\n    \n    private List<PermissionDefinition> loadPermissionDefinitions() {\n        // 从配置文件或注解扫描加载权限定义\n        // ...\n        return definitions;\n    }\n    \n    private void initSystemRoles() {\n        // 初始化系统管理员角色\n        if (!roleService.existsRoleByCode(\"ADMIN\")) {\n            Role adminRole = new Role();\n            adminRole.setCode(\"ADMIN\");\n            adminRole.setName(\"系统管理员\");\n            adminRole.setRoleType(RoleType.SYSTEM.getValue());\n            adminRole.setEnabled(true);\n            \n            roleService.createRole(adminRole);\n            \n            // 分配所有权限\n            List<Permission> allPermissions = permissionService.getAllPermissions();\n            for (Permission permission : allPermissions) {\n                roleService.grantPermissionToRole(adminRole.getId(), permission.getId(), null);\n            }\n        }\n        \n        // 初始化其他系统角色...\n    }\n}\n```\n\n## 9. 安全性考虑\n\n1. **权限分级管理**：不同级别的管理员只能管理其权限范围内的用户和角色\n\n2. **权限传播限制**：用户只能分配自己拥有的权限给其他用户\n\n3. **敏感操作多重验证**：敏感权限操作需要二次验证或多人审批\n\n4. **权限变更通知**：重








]    